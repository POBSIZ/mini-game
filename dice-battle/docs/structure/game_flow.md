## 🔄 게임 플로우

라운드 처리의 표준 시퀀스와 각 단계의 입력/출력을 정의합니다.

### 라운드 시퀀스

1. 라운드 시작 전
   - 입력: 성향(공격/방어/밸런스) 선언, 사전 카드 후보
   - 출력: 선언 고정, 사전 카드 사용 기록(0~2장, 같은 종류 1장 제한)
2. 사전 카드(선택)
   - 사용 가능: 🛡️ 방어(에너지 1), ⚡ 부스트(에너지 4)
3. 주사위 굴림
   - 성향별 성공/실패, 특수 주사위 잠재(공격:6, 방어:2)
4. 사후 카드(선택)
   - 사용 가능: ⚔️ 공격(2), 🦹 스틸(2), 🧹 리셋(4)
5. 점수 계산(순서 고정)
   - 기본 → 상황 보너스 → 특수 주사위 → 카드 → 방어막 → 이벤트 → 합산
6. 방어막 판정
   - 차단 가능: ⚔️/⚡/🔥(이번 라운드 -3만)/🦹
7. 이벤트 처리(라운드 종료)
   - 드로우 → 즉시/지연 구분 → 즉시 적용 → 지연 예약(🍀/🌙/🎲)
8. 누적/기록
   - 라운드 점수 → 총점, 게이지/연승·연패/사용 카드/이벤트 상태 갱신

### 상태 머신 핵심 전이

- `PreRound` → `PreCard` → `Roll` → `PostCard` → `Score` → `ShieldCheck` → `Event` → `Accumulate`

### 제약 검증 체크리스트

- 라운드당 카드 최대 2장, 같은 종류 1장
- 카드 사용 시점 준수(사전/사후)
- 에너지 상한(≤10), 필요량 충족
- 방어막 보유 상한(≤2)

### 구현 가이드 (순수 JS)

- 엔진 단계 함수
  - `preRound(engineState)` → 성향 확정/사전 카드 검증
  - `rollPhase(engineState, rng)` → 주사위 굴림/특수 효과 이벤트 발행
  - `postCard(engineState)` → 사후 카드 처리(순서/제약)
  - `scorePhase(engineState)` → 점수 시스템 호출(순서 보장)
  - `eventPhase(engineState)` → 이벤트 드로우/적용/예약
  - `accumulate(engineState)` → 라운드 → 총점
- 각 단계 입출력은 불변 객체 반환: `(state) => newState`
- 이벤트버스로 `phase:*` 이벤트 발행하여 디버깅/UI 연동
