## 🏗️ 아키텍처 개요

규칙서(`dice_battle_rule.md`)와 AI 가이드(`ai_strategy_guide.md`)를 소프트웨어 구조로 투영한 개요입니다.

### 레이어 구성

- 핵심 도메인
  - 게임/라운드 엔진: 라운드 단계 실행, 효과 적용 순서 유지(기본→보너스→특수주사위→카드→방어막→이벤트→합산)
  - 도메인 모델: `Game`, `Round`, `Player(AI)`, `Dice`, `CardDeck`, `EventDeck`, `Shield`, `Energy`, `Gauge`, `Score` 등
- 시스템 모듈
  - 주사위, 에너지, 카드, 방어막, 이벤트, 점수 계산 모듈로 분리
  - 각 모듈은 순수 함수(or 클래스)로 규칙을 캡슐화하고, 부작용은 엔진이 조정
- AI 계층
  - 난이도 파라미터, 성향 선택 로직, 카드/자원 정책을 별도 모듈로 유지
  - 공개/부분/숨김 정보 경계를 인터페이스로 분리
- UI/입출력(선택)
  - 도메인 이벤트를 기반으로 상태 표시와 애니메이션 처리

### 데이터 흐름

1. 입력: 성향 선언, 카드 사용(시점 제약), 주사위 결과, 이벤트 드로우
2. 엔진: 라운드 단계 진행 및 우선순위/제약 검증
3. 모듈: 규칙 계산(감점 누적, 곱셈 효과, 차단 범위 등)
4. 출력: 라운드 점수, 총점, 방어막/게이지/에너지 상태, 지연 이벤트 예약

### 불변 규칙 (엔진 수준)

- 라운드 처리 순서 불변: 기본→보너스→특수주사위→카드→방어막→이벤트→합산
- 카드 사용 제약: 라운드당 최대 2장, 같은 종류 1장, 시점 준수
- 방어막 차단 범위 고정: 공격/화염(부분)/스틸/공격카드만 차단
- 에너지 상한: 10 유지, 요구량 미달 시 사용 금지
- 게이지: 5 도달 시 카드 1장 지급 후 0, 초과 이월

### 모듈 경계와 의존성

- `scoring_system`는 모든 모듈의 결과를 종합하되, 계산 순서 규칙을 단일 책임으로 유지
- `event_system`은 즉시/지연 효과를 구분해 스케줄러(다음 라운드 큐)에 위임
- `ai_system`은 도메인 상태를 읽기만 하고, 실제 실행은 엔진에 요청(명령 모델)

### 확장 포인트

- 카드/이벤트 추가: 덱 구성, 확률, 사용 시점, 우선순위만 정의하면 엔진에 자동 편입
- 난이도 튜닝: 파라미터 테이블로 독립 관리
- 시뮬레이터: AI/규칙 회귀 테스트에 사용(시드 고정 주사위)

### 구현 가이드 (순수 JS)

- 엔트리: `src/index.js`에서 `createEngine()` 초기화 후 `startGame()` 호출
- 엔진: `src/core/engine.js`
  - `createEngine({ rng, events })`
  - `startGame(config)` / `startRound()` / `endRound()`
  - 내부 의존: `systems/*` 모듈의 순수 함수 호출
- 상태: `src/core/state.js`
  - `createInitialState(config)` → `{ players, round, decks, scores, scheduled }`
  - 얕은 복제로 변경 추적, 불변 업데이트
- 이벤트버스: `src/shared/events.js` → `emit('phase:score', payload)` 등
- 테스트: 각 시스템은 순수 함수이므로 Jest 없이도 간단한 어설션 가능
