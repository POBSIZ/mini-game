// SPA 라우팅 및 게임 상태 관리
let currentScreen = 'main-menu';
let ws;
let currentPlayer = {
  id: null,
  name: null,
  isOwner: false,
  side: null
};
let currentRoom = {
  id: null,
  name: null,
  status: null
};

// 게임 상태
let gameState = {
  turn: "W",
  roll: null,
  pieces: { W: [1, 3, 5, 7, 9], B: [2, 4, 6, 8, 10] },
  gameOver: false,
  gameId: null
};

// 대기실 상태
let waitingState = {
  players: [],
  readyPlayers: new Set(),
  canStart: false
};

// URL 파라미터 처리
const params = new URLSearchParams(location.search);
const room = params.get("room");
const player = params.get("player");

// WebSocket 연결
function connectGameWS() {
  ws = new WebSocket("ws://localhost:8080/ws");

  ws.onopen = () => {
    console.log("WebSocket 연결됨");
    // 하트비트 시작
    startHeartbeat();
  };

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);
    console.log("수신:", msg);
    
    switch (msg.type) {
      case "ROOM_LIST":
        handleRoomList(msg.data);
        break;
      case "ROOM_CREATED":
        handleRoomCreated(msg.data);
        break;
      case "ROOM_JOINED":
        handleRoomJoined(msg.data);
        break;
      case "PLAYER_JOINED":
        handlePlayerJoined(msg.data);
        break;
      case "PLAYER_LEFT":
        handlePlayerLeft(msg.data);
        break;
      case "PLAYER_READY":
        handlePlayerReady(msg.data);
        break;
      case "PLAYER_UNREADY":
        handlePlayerUnready(msg.data);
        break;
      case "GAME_STARTED":
        handleGameStarted(msg.data);
        break;
      case "STICKS_ROLLED":
        handleSticksRolled(msg.data);
        break;
      case "PIECE_MOVED":
        handlePieceMoved(msg.data);
        break;
      case "TURN_CHANGED":
        handleTurnChanged(msg.data);
        break;
      case "GAME_ENDED":
        handleGameEnded(msg.data);
        break;
      case "GAME_RESET":
        handleGameReset(msg.data);
        break;
      case "CHAT_RECEIVED":
        handleChatReceived(msg.data);
        break;
      case "PLAYER_STATUS":
        handlePlayerStatus(msg.data);
        break;
      case "ERROR":
        handleError(msg.data);
        break;
      default:
        console.log("알 수 없는 메시지 타입:", msg.type);
    }
  };

  ws.onclose = () => {
    console.log("WebSocket 연결 끊어짐");
    stopHeartbeat();
    setTimeout(connectGameWS, 1000);
  };

  ws.onerror = (error) => {
    console.error("WebSocket 에러:", error);
  };
}

// 하트비트 관리
let heartbeatInterval;
function startHeartbeat() {
  heartbeatInterval = setInterval(() => {
    if (ws && ws.readyState === WebSocket.OPEN && currentRoom.id) {
      ws.send(JSON.stringify({
        type: "HEARTBEAT",
        data: {
          roomId: currentRoom.id,
          playerId: currentPlayer.id
        }
      }));
    }
  }, 30000); // 30초마다
}

function stopHeartbeat() {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
  }
}

// 메시지 핸들러들
function handleRoomList(data) {
  const roomsList = document.getElementById("rooms-list");
  if (!roomsList) return;
  
  roomsList.innerHTML = "";
  if (data.rooms.length === 0) {
    roomsList.innerHTML = '<div class="no-rooms">현재 생성된 방이 없습니다.</div>';
    return;
  }
  
  data.rooms.forEach((room) => {
    const roomItem = createRoomItem(room);
    roomsList.appendChild(roomItem);
  });
}

function handleRoomCreated(data) {
  currentRoom.id = data.roomId;
  currentRoom.name = data.roomName;
  currentRoom.status = data.status;
  currentPlayer.isOwner = true;
  
  showMessage(`방이 생성되었습니다! 방 코드: ${data.roomId}`, "success");
  joinWaitingRoom(data.roomId, data.roomName, currentPlayer.name, true);
}

function handleRoomJoined(data) {
  currentRoom.id = data.roomId;
  currentRoom.name = data.roomName;
  currentRoom.status = data.status;
  
  // 플레이어 정보 설정
  const player = data.players.find(p => p.playerName === currentPlayer.name);
  if (player) {
    currentPlayer.id = player.playerId;
    currentPlayer.isOwner = player.isOwner;
    currentPlayer.side = player.side;
  }
  
  // 대기실 상태 설정
  waitingState.players = data.players;
  waitingState.readyPlayers = new Set(
    data.players.filter(p => p.isReady).map(p => p.playerId)
  );
  
  joinWaitingRoom(data.roomId, data.roomName, currentPlayer.name, false);
}

function handlePlayerJoined(data) {
  waitingState.players.push(data.player);
  updatePlayersList();
  addChatMessage("system", `${data.player.playerName}님이 방에 참가했습니다.`);
}

function handlePlayerLeft(data) {
  waitingState.players = waitingState.players.filter(p => p.playerId !== data.playerId);
  waitingState.readyPlayers.delete(data.playerId);
  updatePlayersList();
  updateStartButton();
  addChatMessage("system", `${data.playerName}님이 방을 나갔습니다.`);
  
  // 방장이 나간 경우 새로운 방장 설정
  if (data.newOwner) {
    const newOwner = waitingState.players.find(p => p.playerId === data.newOwner);
    if (newOwner) {
      addChatMessage("system", `${newOwner.playerName}님이 새로운 방장이 되었습니다.`);
      if (newOwner.playerId === currentPlayer.id) {
        currentPlayer.isOwner = true;
        updateStartButton();
      }
    }
  }
}

function handlePlayerReady(data) {
  if (data.isReady) {
    waitingState.readyPlayers.add(data.playerId);
  } else {
    waitingState.readyPlayers.delete(data.playerId);
  }
  updatePlayersList();
  updateStartButton();
  
  const player = waitingState.players.find(p => p.playerId === data.playerId);
  if (player) {
    const action = data.isReady ? "준비 완료" : "준비 취소";
    addChatMessage("system", `${player.playerName}님이 ${action}했습니다.`);
  }
}

function handlePlayerUnready(data) {
  waitingState.readyPlayers.delete(data.playerId);
  updatePlayersList();
  updateStartButton();
  
  const player = waitingState.players.find(p => p.playerId === data.playerId);
  if (player) {
    addChatMessage("system", `${player.playerName}님이 준비를 취소했습니다.`);
  }
}

function handleGameStarted(data) {
  currentRoom.status = "playing";
  gameState.gameId = data.gameId;
  gameState.turn = data.initialTurn;
  gameState.pieces = data.gameState.pieces;
  gameState.gameOver = false;
  
  // 플레이어 정보 업데이트
  waitingState.players = data.players;
  const player = data.players.find(p => p.playerId === currentPlayer.id);
  if (player) {
    currentPlayer.side = player.side;
  }
  
  showScreen('game-screen');
  initGame();
  addChatMessage("system", "게임이 시작되었습니다!");
}

function handleSticksRolled(data) {
  gameState.roll = data.roll;
  gameState.turn = data.turn;
  
  // 주사위 UI 업데이트
  updateSticksUI(data.faces);
  updateTurnUI();
  
  if (data.canMove) {
    highlightMovablePieces();
  } else {
    passTurnIfNoMoves();
  }
}

function handlePieceMoved(data) {
  const move = data.move;
  gameState.pieces = data.gameState.pieces;
  gameState.turn = data.gameState.turn;
  gameState.roll = data.gameState.roll;
  gameState.gameOver = data.gameState.gameOver;
  
  // 말 이동 애니메이션
  animateMove(move.from, move.to, move.side, () => {
    draw();
    updateTurnUI();
    
    if (move.captured) {
      addChatMessage("system", `${move.side === 'W' ? '흰말' : '검은말'}이 상대방 말을 잡았습니다!`);
    }
    
    if (move.extraTurn) {
      addChatMessage("system", `${move.side === 'W' ? '흰말' : '검은말'} 추가턴!`);
    }
  });
}

function handleTurnChanged(data) {
  gameState.turn = data.newTurn;
  updateTurnUI();
  addChatMessage("system", `${data.newTurn === 'W' ? '흰말' : '검은말'} 차례입니다.`);
}

function handleGameEnded(data) {
  gameState.gameOver = true;
  gameState.pieces = data.finalState.pieces;
  
  const winner = data.winner === 'W' ? '흰말' : '검은말';
  const winnerName = data.winnerName;
  
  showMessage(`${winnerName} (${winner}) 승리!`, "success");
  addChatMessage("system", `게임이 종료되었습니다. ${winnerName}님이 승리했습니다!`);
  
  // 게임 종료 후 대기실로 돌아가기
  setTimeout(() => {
    showWaitingRoom();
  }, 3000);
}

function handleGameReset(data) {
  gameState = {
    turn: "W",
    roll: null,
    pieces: { W: [1, 3, 5, 7, 9], B: [2, 4, 6, 8, 10] },
    gameOver: false,
    gameId: data.newGameId
  };
  
  draw();
  updateTurnUI();
  addChatMessage("system", "게임이 리셋되었습니다.");
}

function handleChatReceived(data) {
  addChatMessage("player", data.message, data.playerName, data.playerId === currentPlayer.id);
}

function handlePlayerStatus(data) {
  if (data.status === "disconnected") {
    addChatMessage("system", "플레이어가 연결이 끊어졌습니다.");
  } else if (data.status === "connected") {
    addChatMessage("system", "플레이어가 다시 연결되었습니다.");
  }
}

function handleError(data) {
  showMessage(`에러: ${data.message}`, "error");
  console.error("서버 에러:", data);
}

// 화면 전환 함수들
function showScreen(screenId) {
  document.querySelectorAll('.screen').forEach(screen => {
    screen.classList.remove('active');
  });
  
  document.getElementById(screenId).classList.add('active');
  currentScreen = screenId;
  
  if (screenId === 'game-screen') {
    initGame();
  }
}

// 메인 메뉴 표시
function showMainMenu() {
  showScreen('main-menu');
  clearMessages();
  // 상태 초기화
  currentPlayer = { id: null, name: null, isOwner: false, side: null };
  currentRoom = { id: null, name: null, status: null };
  waitingState = { players: [], readyPlayers: new Set(), canStart: false };
  gameState = {
    turn: "W",
    roll: null,
    pieces: { W: [1, 3, 5, 7, 9], B: [2, 4, 6, 8, 10] },
    gameOver: false,
    gameId: null
  };
}

// 방 생성 화면 표시
function showCreateRoom() {
  showScreen('main-menu');
  document.querySelector(".game-options").classList.add("hidden");
  document.getElementById("create-room-section").classList.remove("hidden");
  document.getElementById("back-section").classList.remove("hidden");
  clearMessages();
}

// 방 참가 화면 표시
function showJoinRoom() {
  showScreen('main-menu');
  document.querySelector(".game-options").classList.add("hidden");
  document.getElementById("join-room-section").classList.remove("hidden");
  document.getElementById("back-section").classList.remove("hidden");
  clearMessages();
}

// 공개 방 목록 표시
function showPublicRooms() {
  showScreen('main-menu');
  document.querySelector(".game-options").classList.add("hidden");
  document.getElementById("public-rooms-section").classList.remove("hidden");
  document.getElementById("back-section").classList.remove("hidden");
  clearMessages();
  loadPublicRooms();
}

// 대기실 표시
function showWaitingRoom() {
  showScreen('waiting-room');
  
  // 방 정보 업데이트
  const roomNameDisplay = document.getElementById("room-name-display");
  const roomCodeDisplay = document.getElementById("room-code-display");
  
  if (roomNameDisplay) {
    roomNameDisplay.textContent = currentRoom.name || "방 이름";
  }
  if (roomCodeDisplay) {
    roomCodeDisplay.textContent = `방 코드: ${currentRoom.id || "ABC123"}`;
  }
  
  updatePlayersList();
  updateStartButton();
}

// 대기실 참가
function joinWaitingRoom(roomId, roomName, playerName, isOwner) {
  currentRoom.id = roomId;
  currentRoom.name = roomName;
  currentPlayer.name = playerName;
  currentPlayer.isOwner = isOwner;
  
  showWaitingRoom();
  addChatMessage("system", `${playerName}님이 방에 참가했습니다.`);
}

// 게임 화면으로 전환
function startGame(roomCode = null, playerName = null) {
  if (roomCode && playerName) {
    currentPlayer.name = playerName;
    joinGameRoom(roomCode, playerName);
  } else {
    showScreen('game-screen');
  }
}

// 메시지 표시
function showMessage(message, type = "info") {
  const messageArea = document.getElementById("message-area");
  if (!messageArea) return;
  
  const messageDiv = document.createElement("div");
  messageDiv.className = `message ${type}`;
  messageDiv.textContent = message;
  messageArea.appendChild(messageDiv);

  setTimeout(() => {
    if (messageDiv.parentNode) {
      messageDiv.remove();
    }
  }, 5000);
}

// 메시지 초기화
function clearMessages() {
  const messageArea = document.getElementById("message-area");
  if (messageArea) {
    messageArea.innerHTML = "";
  }
}

// 공개 방 목록 로드
function loadPublicRooms() {
  const roomsList = document.getElementById("rooms-list");
  if (!roomsList) return;
  
  roomsList.innerHTML = '<div class="loading">방 목록을 불러오는 중...</div>';
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ 
      type: "GET_ROOM_LIST", 
      data: {
        filters: {
          status: "waiting",
          hasPassword: false
        }
      }
    }));
  }
}

// 방 아이템 생성
function createRoomItem(room) {
  const roomItem = document.createElement("div");
  roomItem.className = "room-item";

  const playerDots = Array.from(
    { length: room.maxPlayers },
    (_, i) =>
      `<div class="player-dot ${i < room.currentPlayers ? "active" : ""}"></div>`
  ).join("");

  const statusText = room.status === "waiting" ? "대기 중" : 
                    room.status === "playing" ? "게임 중" : "종료";

  roomItem.innerHTML = `
    <div class="room-info">
      <div class="room-name">${room.name}</div>
      <div class="room-status">${statusText} • ${room.id}</div>
    </div>
    <div class="player-count">
      <span>${room.currentPlayers}/${room.maxPlayers}</span>
      <div class="player-dots">${playerDots}</div>
    </div>
    <button class="btn-join" ${
      room.status === "playing" ? "disabled" : ""
    } onclick="joinRoom('${room.id}')">
      ${room.status === "playing" ? "게임 중" : "참가"}
    </button>
  `;

  return roomItem;
}

// 방 참가
function joinRoom(roomCode) {
  const playerName = prompt("플레이어 이름을 입력하세요:");
  if (playerName) {
    currentPlayer.name = playerName;
    showMessage(`방 ${roomCode}에 참가 중...`, "success");
    joinGameRoom(roomCode, playerName);
  }
}

// 게임 방 참가
function joinGameRoom(roomCode, playerName) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: "JOIN_ROOM",
      data: {
        roomId: roomCode,
        playerName: playerName
      }
    }));
  }
}

// 플레이어 목록 업데이트
function updatePlayersList() {
  const playersList = document.getElementById("players-list");
  if (!playersList) return;
  
  playersList.innerHTML = "";
  waitingState.players.forEach(player => {
    const playerItem = document.createElement("div");
    playerItem.className = "player-item";
    const isReady = waitingState.readyPlayers.has(player.playerId);
    const isCurrentPlayer = player.playerId === currentPlayer.id;
    const isOwner = player.isOwner;
    
    // 클래스 추가
    if (isOwner) playerItem.classList.add("host");
    if (isReady) playerItem.classList.add("ready");
    
    playerItem.innerHTML = `
      <div class="player-info">
        <div class="player-avatar">${player.playerName.charAt(0).toUpperCase()}</div>
        <span class="player-name">${player.playerName}</span>
        ${isOwner ? '<span class="player-badge host">방장</span>' : ''}
        ${isCurrentPlayer ? '<span class="player-badge current">나</span>' : ''}
      </div>
      <div class="player-status">
        <span class="ready-indicator ${isReady ? 'ready' : 'not-ready'}">
          ${isReady ? '준비완료' : '준비중'}
        </span>
        ${player.side ? `<span class="side-badge ${player.side}">${player.side === 'W' ? '흰말' : '검은말'}</span>` : ''}
      </div>
    `;
    
    playersList.appendChild(playerItem);
  });
}

// 시작 버튼 업데이트
function updateStartButton() {
  const startBtn = document.getElementById("start-game-btn");
  if (!startBtn) return;
  
  const allReady = waitingState.players.length >= 2 && 
                   waitingState.players.every(p => waitingState.readyPlayers.has(p.playerId));
  
  startBtn.disabled = !currentPlayer.isOwner || !allReady;
  startBtn.textContent = allReady ? "게임 시작" : "모든 플레이어가 준비되어야 합니다";
  
  // 방장이 아닌 경우 시작 버튼 숨기기
  const hostControls = document.getElementById("host-controls");
  if (hostControls) {
    hostControls.style.display = currentPlayer.isOwner ? "block" : "none";
  }
}

// 게임 시작 요청
function startGameRequest() {
  if (!currentPlayer.isOwner) return;
  
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: "START_GAME",
      data: {
        roomId: currentRoom.id,
        playerId: currentPlayer.id
      }
    }));
  }
}

// 준비 상태 변경
function toggleReadyStatus() {
  const isReady = waitingState.readyPlayers.has(currentPlayer.id);
  
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: "READY_STATUS",
      data: {
        roomId: currentRoom.id,
        playerId: currentPlayer.id,
        isReady: !isReady
      }
    }));
  }
}

// 채팅 메시지 전송
function sendChatMessage() {
  const chatInput = document.getElementById("chat-input");
  if (!chatInput || !chatInput.value.trim()) return;
  
  const message = chatInput.value.trim();
  
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: "CHAT_MESSAGE",
      data: {
        roomId: currentRoom.id,
        playerId: currentPlayer.id,
        message: message,
        messageType: "text"
      }
    }));
  }
  
  chatInput.value = "";
}

// 채팅 메시지 추가
function addChatMessage(type, message, playerName = null, isSelf = false) {
  const chatArea = document.getElementById("chat-area");
  if (!chatArea) return;
  
  const messageDiv = document.createElement("div");
  messageDiv.className = `chat-message ${type} ${isSelf ? 'self' : ''}`;
  
  const timestamp = new Date().toLocaleTimeString();
  
  if (type === "system") {
    messageDiv.innerHTML = `<span class="timestamp">${timestamp}</span> <span class="system-message">${message}</span>`;
  } else {
    messageDiv.innerHTML = `<span class="timestamp">${timestamp}</span> <span class="player-name">${playerName}:</span> <span class="message-text">${message}</span>`;
  }
  
  chatArea.appendChild(messageDiv);
  chatArea.scrollTop = chatArea.scrollHeight;
}

// 방 나가기
function leaveRoom() {
  if (ws && ws.readyState === WebSocket.OPEN && currentRoom.id) {
    ws.send(JSON.stringify({
      type: "LEAVE_ROOM",
      data: {
        roomId: currentRoom.id,
        playerId: currentPlayer.id
      }
    }));
  }
  showMainMenu();
}

// 게임 상태 업데이트
function updateGameState(newState) {
  gameState = { ...gameState, ...newState };
  draw();
}

// 주사위 UI 업데이트
function updateSticksUI(faces) {
  const sticksEls = [0, 1, 2, 3].map((i) => document.getElementById("s" + i));
  const result = document.getElementById("result");
  
  sticksEls.forEach((el, i) => {
    if (el) el.classList.toggle("on", !!faces[i]);
  });
  
  if (result) {
    const sum = faces.reduce((a, b) => a + b, 0);
    result.textContent = sum === 0 ? 5 : sum;
  }
}

// 게임 상수들
const SAFE = new Set([15, 26]);
const WATER = 27;
const EXIT = 30;
const GLYPH = { 15: "✚", 26: "★", 27: "⎈", 30: "⟶" };

// 게임 초기화
function initGame() {
  const board = document.getElementById("board");
  const result = document.getElementById("result");
  const statusEl = document.getElementById("status");
  const rollBtn = document.getElementById("roll");
  const resetBtn = document.getElementById("btn-reset");
  const rulesBtn = document.getElementById("btn-rules");
  const turnLabel = document.getElementById("turn-label");
  const turnDot = document.getElementById("turn-dot");
  const sticksEls = [0, 1, 2, 3].map((i) => document.getElementById("s" + i));

  // 이벤트 리스너 등록
  if (rollBtn) {
    rollBtn.addEventListener("click", () => {
      if (gameState.gameOver || gameState.roll || gameState.turn !== currentPlayer.side) return;
      
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "ROLL_STICKS",
          data: {
            roomId: currentRoom.id,
            playerId: currentPlayer.id
          }
        }));
      }
    });
  }

  if (resetBtn) {
    resetBtn.addEventListener("click", () => {
      if (!currentPlayer.isOwner) return;
      
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "RESET_GAME",
          data: {
            roomId: currentRoom.id,
            playerId: currentPlayer.id
          }
        }));
      }
    });
  }

  if (rulesBtn) {
    rulesBtn.addEventListener("click", () =>
      document.getElementById("rules").showModal()
    );
  }

  // 메뉴로 돌아가기 버튼
  const backToMenuBtn = document.getElementById("btn-back-to-menu");
  if (backToMenuBtn) {
    backToMenuBtn.addEventListener("click", leaveRoom);
  }

  // 키보드 이벤트
  document.addEventListener("keydown", (e) => {
    if (e.key === "r" || e.key === "R") {
      if (!gameState.roll && !gameState.gameOver && gameState.turn === currentPlayer.side) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: "ROLL_STICKS",
            data: {
              roomId: currentRoom.id,
              playerId: currentPlayer.id
            }
          }));
        }
      }
    }
  });

  // 초기 게임 그리기
  draw();
}

// 게임 유틸리티 함수들
function indexToRC(idx) {
  const r = Math.floor((idx - 1) / 10);
  let c = (idx - 1) % 10;
  if (r % 2 === 1) c = 9 - c;
  return { r, c };
}

function draw() {
  const board = document.getElementById("board");
  if (!board) return;

  board.innerHTML = "";
  for (let i = 1; i <= 30; i++) {
    const cell = document.createElement("div");
    cell.className =
      "cell" + (SAFE.has(i) ? " safe" : "") + (i === WATER ? " water" : "");
    cell.dataset.idx = i;
    const { r, c } = indexToRC(i);
    cell.style.gridRow = r + 1;
    cell.style.gridColumn = c + 1;
    const idxTag = document.createElement("div");
    idxTag.className = "idx";
    idxTag.textContent = i;
    cell.appendChild(idxTag);
    if (GLYPH[i]) {
      const g = document.createElement("div");
      g.className = "glyph";
      g.textContent = GLYPH[i];
      cell.appendChild(g);
    }
    const p = pieceAt(i);
    if (p) {
      const el = document.createElement("div");
      el.className = "piece " + p.side;
      el.textContent = p.side;
      el.onclick = () => onPieceClick(p.side, p.i);
      cell.appendChild(el);
    }
    board.appendChild(cell);
  }
  updateTurnUI();
  highlightMovablePieces();
}

function updateTurnUI() {
  const turnLabel = document.getElementById("turn-label");
  const turnDot = document.getElementById("turn-dot");
  if (!turnLabel || !turnDot) return;

  const name = gameState.turn === "W" ? "흰말 차례" : "검은말 차례";
  const isMyTurn = gameState.turn === currentPlayer.side;
  turnLabel.textContent = name + (gameState.roll ? ` · 이동: ${gameState.roll}` : "") + (isMyTurn ? " (내 차례)" : "");
  turnDot.className = "turn-dot " + gameState.turn;
}

function pieceAt(idx) {
  for (const s of ["W", "B"]) {
    const k = gameState.pieces[s].indexOf(idx);
    if (k !== -1) return { side: s, i: k };
  }
  return null;
}

function isAdjacentSameColor(idx, side) {
  const L = pieceAt(idx - 1),
    R = pieceAt(idx + 1);
  return (L && L.side === side) || (R && R.side === side);
}

function isBlockadeSquare(idx, side) {
  const here = pieceAt(idx);
  if (!here || here.side !== side) return false;
  return isAdjacentSameColor(idx, side);
}

function pathBlockedByOpponent(from, to, opp) {
  for (let s = from + 1; s <= to; s++) {
    if (isBlockadeSquare(s, opp)) return true;
  }
  return false;
}

function hasLegalMove(side, rollVal) {
  const opp = side === "W" ? "B" : "W";
  for (let i = 0; i < gameState.pieces[side].length; i++) {
    const from = gameState.pieces[side][i];
    if (from === 0) continue;
    const to = from + rollVal;
    if (to > EXIT) continue;
    if (pathBlockedByOpponent(from, to, opp)) continue;
    const occ = pieceAt(to);
    if (occ && occ.side === side) continue;
    if (occ && (SAFE.has(to) || isAdjacentSameColor(to, occ.side))) continue;
    if (to === WATER) {
      const back = !pieceAt(15) ? 15 : !pieceAt(26) ? 26 : null;
      if (!back) continue;
    }
    return true;
  }
  return false;
}

function highlightMovablePieces() {
  document
    .querySelectorAll(".piece")
    .forEach((p) => p.classList.remove("can-move", "dim"));
  if (!gameState.roll || gameState.turn !== currentPlayer.side) {
    document.querySelectorAll(".piece").forEach((p) => p.classList.add("dim"));
    return;
  }
  const side = gameState.turn;
  const opp = side === "W" ? "B" : "W";
  for (let i = 0; i < gameState.pieces[side].length; i++) {
    const from = gameState.pieces[side][i];
    if (from === 0) continue;
    const to = from + gameState.roll;
    if (to > EXIT) continue;
    if (pathBlockedByOpponent(from, to, opp)) continue;
    const occ = pieceAt(to);
    if (occ && occ.side === side) continue;
    if (occ && (SAFE.has(to) || isAdjacentSameColor(to, occ.side))) continue;
    if (to === WATER) {
      const back = !pieceAt(15) ? 15 : !pieceAt(26) ? 26 : null;
      if (!back) continue;
    }
    const cell = document.querySelector('.cell[data-idx="' + from + '"]');
    const el = cell && cell.querySelector(".piece");
    if (el) el.classList.add("can-move");
  }
  document.querySelectorAll(".piece").forEach((el) => {
    if (!el.classList.contains("can-move")) el.classList.add("dim");
  });
}

function passTurnIfNoMoves() {
  if (gameState.gameOver || gameState.roll == null) return;
  if (!hasLegalMove(gameState.turn, gameState.roll)) {
    const statusEl = document.getElementById("status");
    if (statusEl) {
      statusEl.textContent =
        (gameState.turn === "W" ? "흰말" : "검은말") +
        " 이동 가능한 수 없음 — 턴을 넘깁니다.";
    }
    clearHighlights();
  } else {
    const statusEl = document.getElementById("status");
    if (statusEl) statusEl.textContent = "";
  }
}

function onPieceClick(side, i) {
  if (gameState.gameOver || side !== gameState.turn || side !== currentPlayer.side) return;
  if (!gameState.roll) return;
  showMoves(side, i);
}

function showMoves(side, i) {
  clearHighlights();
  const from = gameState.pieces[side][i];
  const to = from + gameState.roll;
  if (to > EXIT) return;
  const opp = side === "W" ? "B" : "W";
  if (pathBlockedByOpponent(from, to, opp)) return;
  const occ = pieceAt(to);
  if (occ) {
    if (occ.side === side) return;
    if (SAFE.has(to) || isAdjacentSameColor(to, occ.side)) return;
  }
  if (to === WATER) {
    const back = !pieceAt(15) ? 15 : !pieceAt(26) ? 26 : null;
    if (!back) return;
  }
  const cell = document.querySelector('.cell[data-idx="' + to + '"]');
  if (cell) {
    cell.classList.add("highlight");
    const tip = document.createElement("div");
    tip.className = "target-label";
    tip.textContent =
      to === EXIT ? "탈출" : to === WATER ? "물 → 귀환" : "이동";
    cell.appendChild(tip);
    cell.onclick = () => move(side, i, to);
  }
}

function clearHighlights() {
  document.querySelectorAll(".cell").forEach((c) => {
    c.classList.remove("highlight");
    c.onclick = null;
    const t = c.querySelector(".target-label");
    if (t) t.remove();
  });
}

function checkWin(side) {
  const win = gameState.pieces[side].every((p) => p === 0);
  if (win) {
    gameState.gameOver = true;
    const statusEl = document.getElementById("status");
    if (statusEl) {
      statusEl.textContent =
        (side === "W" ? "흰말" : "검은말") + " 승리! 모두 탈출했습니다.";
    }
  }
  return win;
}

function animateMove(fromIdx, toIdx, side, done) {
  const fromCell = document.querySelector('.cell[data-idx="' + fromIdx + '"]');
  const toCell =
    document.querySelector('.cell[data-idx="' + toIdx + '"]') ||
    document.querySelector('.cell[data-idx="30"]');
  if (!fromCell || !toCell) {
    done();
    return;
  }
  const pieceEl = fromCell.querySelector(".piece");
  const fb = fromCell.getBoundingClientRect();
  const tb = toCell.getBoundingClientRect();
  const ghost = document.createElement("div");
  ghost.className = "float-piece " + side;
  ghost.style.background =
    side === "W"
      ? "linear-gradient(180deg,#e6f0ff,#cfe0ff)"
      : "linear-gradient(180deg,#2b2f4f,#1c203b)";
  ghost.style.color = side === "W" ? "#09121f" : "#e7eaff";
  ghost.textContent = side;
  document.body.appendChild(ghost);
  ghost.style.left = fb.left + window.scrollX + (fb.width - 58) / 2 + "px";
  ghost.style.top = fb.top + window.scrollY + (fb.height - 58) / 2 + "px";
  ghost.style.transition = "transform .28s ease";
  const dx = tb.left - fb.left;
  const dy = tb.top - fb.top;
  requestAnimationFrame(() => {
    ghost.style.transform = "translate(" + dx + "px," + dy + "px)";
  });
  setTimeout(() => {
    ghost.remove();
    done();
  }, 300);
}

function move(side, i, to) {
  if (gameState.gameOver || side !== currentPlayer.side) return;
  
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: "MOVE_PIECE",
      data: {
        roomId: currentRoom.id,
        playerId: currentPlayer.id,
        move: {
          side: side,
          pieceIndex: i,
          from: gameState.pieces[side][i],
          to: to,
          roll: gameState.roll
        }
      }
    }));
  }
}

// 초기화
connectGameWS();

// 이벤트 리스너 등록
document.addEventListener("DOMContentLoaded", function () {
  // 방 생성 폼 제출
  const createRoomForm = document.getElementById("create-room-form");
  if (createRoomForm) {
    createRoomForm.addEventListener("submit", function (e) {
      e.preventDefault();
      const roomName = document.getElementById("room-name").value;
      const playerName = document.getElementById("player-name").value;
      const password = document.getElementById("room-password").value;

      if (!roomName || !playerName) {
        showMessage("방 이름과 플레이어 이름을 입력해주세요.", "error");
        return;
      }

      currentPlayer.name = playerName;
      showMessage("방을 생성하는 중...", "success");

      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(
          JSON.stringify({
            type: "CREATE_ROOM",
            data: {
              roomName,
              playerName,
              password: password || null,
              maxPlayers: 2,
            },
          })
        );
      }
    });
  }

  // 방 참가 폼 제출
  const joinRoomForm = document.getElementById("join-room-form");
  if (joinRoomForm) {
    joinRoomForm.addEventListener("submit", function (e) {
      e.preventDefault();
      const roomCode = document.getElementById("room-code").value;
      const playerName = document.getElementById("join-player-name").value;
      const password = document.getElementById("join-room-password").value;

      if (!roomCode || !playerName) {
        showMessage("방 코드와 플레이어 이름을 입력해주세요.", "error");
        return;
      }

      currentPlayer.name = playerName;
      showMessage(`방 ${roomCode}에 참가 중...`, "success");

      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: "JOIN_ROOM",
          data: {
            roomId: roomCode,
            playerName: playerName,
            password: password || null
          }
        }));
      }
    });
  }

  // 뒤로가기 버튼
  const backBtn = document.getElementById("back-btn");
  if (backBtn) {
    backBtn.addEventListener("click", showMainMenu);
  }

  // 대기실에서 메인 메뉴로 가기 버튼
  const backToMenuFromWaitingBtn = document.getElementById("btn-back-to-menu-from-waiting");
  if (backToMenuFromWaitingBtn) {
    backToMenuFromWaitingBtn.addEventListener("click", leaveRoom);
  }

  // 채팅 입력 이벤트
  const chatInput = document.getElementById("chat-input");
  if (chatInput) {
    chatInput.addEventListener("keypress", function(e) {
      if (e.key === "Enter") {
        sendChatMessage();
      }
    });
  }

  // 채팅 전송 버튼
  const sendChatBtn = document.getElementById("send-chat-btn");
  if (sendChatBtn) {
    sendChatBtn.addEventListener("click", sendChatMessage);
  }

  // 준비 상태 토글 버튼
  const readyBtn = document.getElementById("ready-btn");
  if (readyBtn) {
    readyBtn.addEventListener("click", toggleReadyStatus);
  }

  // 게임 시작 버튼
  const startGameBtn = document.getElementById("start-game-btn");
  if (startGameBtn) {
    startGameBtn.addEventListener("click", startGameRequest);
  }

  // 방 나가기 버튼
  const leaveRoomBtn = document.getElementById("leave-room-btn");
  if (leaveRoomBtn) {
    leaveRoomBtn.addEventListener("click", leaveRoom);
  }

  // URL 파라미터가 있으면 게임 화면으로 바로 이동
  if (room && player) {
    currentPlayer.name = player;
    startGame(room, player);
  }
});
