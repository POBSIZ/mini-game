<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>í•œ íŒŒì¼ HTML ë¡œê·¸ë¼ì´í¬</title>
    <style>
      :root {
        --bg: #0b0d10;
        --panel: #12161b;
        --wall: #1f2937;
        --floor: #0f172a;
        --floor-seen: #0b1220;
        --text: #e5e7eb;
        --muted: #9ca3af;
        --accent: #38bdf8;
        --danger: #f87171;
        --good: #34d399;
        --gold: #fbbf24;
        --food: #f59e0b;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: radial-gradient(
          1200px 800px at 60% -10%,
          #111827 0%,
          var(--bg) 60%
        );
        color: var(--text);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          "Liberation Mono", "Courier New", monospace;
      }
      .wrap {
        display: grid;
        grid-template-rows: auto 1fr auto;
        gap: 10px;
        max-width: 1100px;
        margin: 0 auto;
        padding: 16px;
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      header h1 {
        font-size: 18px;
        margin: 0;
        letter-spacing: 0.5px;
      }
      header .mini {
        color: var(--muted);
        font-size: 12px;
      }
      .panel {
        background: linear-gradient(180deg, #0d1117 0%, var(--panel) 100%);
        border: 1px solid #1f2937;
        border-radius: 14px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35),
          inset 0 1px 0 rgba(255, 255, 255, 0.02);
        overflow: hidden;
      }
      #hud {
        display: grid;
        grid-template-columns: 1fr auto;
        align-items: center;
        padding: 10px 12px;
        gap: 8px;
        border-bottom: 1px solid #111827;
        font-size: 14px;
      }
      #hud .stats span {
        margin-right: 14px;
      }
      #hud .stats b {
        color: var(--accent);
      }
      #hud .btns button {
        background: #0b1220;
        border: 1px solid #1e293b;
        color: var(--text);
        border-radius: 10px;
        padding: 6px 10px;
        cursor: pointer;
        font: inherit;
      }
      #hud .btns button:hover {
        border-color: #334155;
      }
      #game-holder {
        position: relative;
      }
      canvas {
        display: block;
        width: 100%;
        height: auto;
        image-rendering: pixelated;
        background: #07090d;
      }
      #help {
        padding: 10px 12px;
        border-top: 1px solid #111827;
        font-size: 13px;
        color: var(--muted);
      }
      #log {
        padding: 10px 12px;
        border-top: 1px solid #111827;
        font-size: 13px;
        min-height: 3lh;
      }
      #log .msg {
        opacity: 0.9;
      }
      #log .msg.dim {
        opacity: 0.6;
      }
      a {
        color: var(--accent);
        text-decoration: none;
      }
      /* Inventory modal */
      #inv[hidden] {
        display: none;
      }
      #inv {
        position: absolute;
        inset: 8px;
        background: rgba(6, 8, 11, 0.88);
        border: 1px solid #1f2937;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        display: flex;
        flex-direction: column;
        backdrop-filter: blur(4px);
      }
      #inv .title {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 12px;
        border-bottom: 1px solid #111827;
        font-size: 14px;
      }
      #inv .title .right {
        color: var(--muted);
        font-size: 12px;
      }
      #inv .body {
        padding: 8px 12px;
        overflow: auto;
      }
      #inv .item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 6px 8px;
        border: 1px solid #111827;
        border-radius: 8px;
        margin: 6px 0;
        background: linear-gradient(180deg, #0c1117 0%, #0b0f15 100%);
      }
      #inv .item .idx {
        width: 26px;
        text-align: center;
        color: var(--gold);
      }
      #inv .item .name {
        font-weight: 700;
      }
      #inv .item .meta {
        color: var(--muted);
        font-size: 12px;
      }
      #inv .hint {
        color: var(--muted);
        font-size: 12px;
        padding: 6px 12px 10px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <h1>âš”ï¸ í•œ íŒŒì¼ HTML ë¡œê·¸ë¼ì´í¬</h1>
        <div class="mini">
          ì´ë™: <b>WASD/í™”ì‚´í‘œ</b> Â· ëŒ€ê¸°: <b>.</b> Â· ë¬¼ì•½: <b>Q</b> Â· ìŒì‹:
          <b>F</b> Â· ì¸ë²¤í† ë¦¬: <b>I</b> Â· ë‚´ë ¤ê°€ê¸°: <b>&gt;</b> Â· ì¬ì‹œì‘:
          <b>R</b>
        </div>
      </header>

      <div class="panel">
        <div id="hud">
          <div class="stats"></div>
          <div class="btns">
            <button id="btn-inv" title="ì¸ë²¤í† ë¦¬ (I)">ì¸ë²¤í† ë¦¬</button>
            <button id="btn-help" title="ë„ì›€ë§ í† ê¸€">ë„ì›€ë§</button>
            <button id="btn-restart" title="ë‹¤ì‹œ ì‹œì‘">ì¬ì‹œì‘</button>
          </div>
        </div>
        <div id="game-holder">
          <canvas id="game" width="960" height="576"></canvas>
          <div id="inv" hidden>
            <div class="title">
              ì¸ë²¤í† ë¦¬
              <span class="right">ë²ˆí˜¸ í‚¤ë¡œ ì‚¬ìš©/ì¥ì°© Â· Esc/I ë‹«ê¸°</span>
            </div>
            <div class="body"></div>
            <div class="hint">
              í¬ì…˜ì€ <b>Q</b>, ìŒì‹ì€ <b>F</b>ë¡œ ë¹ ë¥´ê²Œ ì‚¬ìš© ê°€ëŠ¥
            </div>
          </div>
        </div>
        <div id="help" hidden>
          <p>
            ì´ ê²Œì„ì€ <b>í•œ ê°œì˜ HTML íŒŒì¼</b>ë§Œìœ¼ë¡œ ë™ì‘í•˜ëŠ” ì‘ì€
            ë¡œê·¸ë¼ì´í¬ì…ë‹ˆë‹¤. í˜„ì¬ ë²„ì „ì€ <b>ê²½í—˜ì¹˜ & ë ˆë²¨ì—…</b>,
            <b>ì¥ë¹„/ì¸ë²¤í† ë¦¬</b>ì— ë”í•´ <b>ë¦¬ìŠ¤í¬ ê´€ë¦¬(ë°°ê³ í”” & í•¨ì •)</b>ì´
            ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤. âœ¨
          </p>
          <ul>
            <li>
              ë°°ê³ í””ì€ ë§¤ í„´ <b>1</b>ì”© ê°ì†Œí•©ë‹ˆë‹¤. 40â†“ì€ ë°°ê³ í”” ê²½ê³ , 0ì´ ë˜ë©´
              ë§¤ í„´ <b>êµ¶ì£¼ë¦¼ í”¼í•´</b>.
            </li>
            <li>
              ìŒì‹(%)ì„ ë¨¹ì–´ ë°°ê³ í””ì„ íšŒë³µí•˜ì„¸ìš”. (F í‚¤ ë˜ëŠ” ì¸ë²¤í† ë¦¬ì—ì„œ ì‚¬ìš©)
            </li>
            <li>
              í•¨ì •ì€ ë³´ì´ì§€ ì•Šë‹¤ê°€ ë°Ÿìœ¼ë©´ ë°œë™(í”¼í•´)í•˜ë©°, ì´í›„ì—” ë³´ì…ë‹ˆë‹¤.
            </li>
            <li>ì•„ì´í…œ: ! í¬ì…˜, ) ë¬´ê¸°, [ ë°©ì–´êµ¬, % ìŒì‹, ^(ë°œë™ í›„) í•¨ì •</li>
          </ul>
        </div>
        <div id="log"></div>
      </div>

      <footer class="mini">Â© ë¸Œë¼ìš°ì €ì—ì„œ 100% ë¡œì»¬ ì‹¤í–‰.</footer>
    </div>

    <script>
      (() => {
        "use strict";
        // ===== Config =====
        const VIEW_W = 40; // íƒ€ì¼ í­(ê°€ë¡œ)
        const VIEW_H = 24; // íƒ€ì¼ ë†’ì´(ì„¸ë¡œ)
        const FOV_RADIUS = 8;
        const MAX_LEVEL = 5; // ë˜ì „ ìµœëŒ€ ì¸µ
        const START_HP = 24;
        const LOG_LINES = 6;
        const HUNGER_MAX = 100; // ë°°ê³ í”” ìµœëŒ€ì¹˜
        const HUNGER_WARN = 40; // ê²½ê³  ì„ê³„ê°’

        const COLORS = {
          wall: "#1f2937",
          floor: "#0f172a",
          floorSeen: "#0b1220",
          void: "#06080b",
          stairs: "#fbbf24",
          player: "#38bdf8",
          enemy: "#f87171",
          potion: "#34d399",
          gear: "#fbbf24",
          food: "#f59e0b",
          text: "#e5e7eb",
          dim: "#6b7280",
        };

        // ===== Loot Tables =====
        const WEAPONS = [
          { name: "ë…¹ìŠ¨ ë‹¨ê²€", dmg: [0, 1], tier: 1, w: 2 },
          { name: "ë‹¨ê²€ +1", dmg: [1, 2], tier: 1, w: 3 },
          { name: "ì¥ê²€ +2", dmg: [2, 3], tier: 2, w: 3 },
          { name: "ë£¬ ë¸”ë ˆì´ë“œ +3", dmg: [3, 4], tier: 3, w: 1 },
        ];
        const ARMORS = [
          { name: "ì²œì˜·", def: 1, tier: 1, w: 3 },
          { name: "ê°€ì£½ ê°‘ì˜·", def: 2, tier: 1, w: 3 },
          { name: "ì‚¬ìŠ¬ ê°‘ì˜·", def: 3, tier: 2, w: 2 },
          { name: "ë£¬ ê°‘ì˜·", def: 4, tier: 3, w: 1 },
        ];

        // ===== DOM =====
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const hudEl = document.querySelector("#hud .stats");
        const logEl = document.getElementById("log");
        const helpEl = document.getElementById("help");
        const invEl = document.getElementById("inv");
        const invBody = invEl.querySelector(".body");
        document.getElementById("btn-help").onclick = () =>
          helpEl.toggleAttribute("hidden");
        document.getElementById("btn-restart").onclick = () => restart();
        document.getElementById("btn-inv").onclick = () => toggleInventory();

        // ===== Utilities =====
        const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
        const rnd = (n) => Math.floor(Math.random() * n);
        const between = (a, b) => a + rnd(b - a + 1);
        const inBounds = (x, y, w = state.w, h = state.h) =>
          x >= 0 && y >= 0 && x < w && y < h;
        const keyDirs = {
          ArrowUp: [0, -1],
          ArrowDown: [0, 1],
          ArrowLeft: [-1, 0],
          ArrowRight: [1, 0],
          w: [0, -1],
          s: [0, 1],
          a: [-1, 0],
          d: [1, 0],
          W: [0, -1],
          S: [0, 1],
          A: [-1, 0],
          D: [1, 0],
        };
        const deepCopy = (o) => JSON.parse(JSON.stringify(o));

        // ===== Game State =====
        const state = {
          level: 1,
          w: VIEW_W,
          h: VIEW_H,
          map: [],
          seen: [],
          visible: [],
          player: {
            x: 0,
            y: 0,
            hp: START_HP,
            max: START_HP,
            atk: [2, 6],
            ply: 1,
            exp: 0,
            next: 20,
            hunger: HUNGER_MAX,
          },
          equip: { weapon: null, armor: null },
          enemies: [],
          items: [], // ground items: {x,y,type:'potion'|'weapon'|'armor'|'food', ...}
          traps: [], // {x,y,armed:true, seen:false, kind:'spike'}
          inv: [], // inventory list
          msgs: [],
          over: false,
          tileSize: 24,
          invOpen: false,
        };

        const nextExp = (lv) => 20 + (lv - 1) * 15; // í•„ìš” EXP ê³µì‹

        // ===== Map Gen (rooms + corridors) =====
        function genLevel() {
          const W = state.w,
            H = state.h;
          state.map = Array.from({ length: H }, () => Array(W).fill(1));
          state.seen = Array.from({ length: H }, () => Array(W).fill(false));
          state.visible = Array.from({ length: H }, () => Array(W).fill(false));
          state.traps = [];

          const rooms = [];
          const roomCount = between(8, 12);
          for (let i = 0; i < roomCount; i++) {
            const rw = between(4, 9),
              rh = between(3, 7);
            const rx = between(1, W - rw - 2),
              ry = between(1, H - rh - 2);
            for (let y = ry; y < ry + rh; y++)
              for (let x = rx; x < rx + rw; x++) state.map[y][x] = 0;
            rooms.push({
              x: rx,
              y: ry,
              w: rw,
              h: rh,
              cx: Math.floor(rx + rw / 2),
              cy: Math.floor(ry + rh / 2),
            });
          }
          rooms.sort((a, b) => a.cx - b.cx);
          for (let i = 1; i < rooms.length; i++)
            connect(rooms[i - 1], rooms[i]);

          state.player.x = rooms[0].cx;
          state.player.y = rooms[0].cy;

          let far = rooms[0],
            farDist = -1;
          for (const r of rooms) {
            const d = dist(rooms[0].cx, rooms[0].cy, r.cx, r.cy);
            if (d > farDist) {
              farDist = d;
              far = r;
            }
          }
          state.map[far.cy][far.cx] = 2; // stairs

          const floorCells = [];
          for (let y = 1; y < H - 1; y++)
            for (let x = 1; x < W - 1; x++)
              if (state.map[y][x] === 0) floorCells.push({ x, y });

          shuffle(floorCells);
          const enemyCount = between(7 + state.level, 10 + state.level);
          for (let i = 0; i < enemyCount && floorCells.length; i++) {
            const { x, y } = floorCells.pop();
            if (
              (x === state.player.x && y === state.player.y) ||
              state.map[y][x] !== 0
            )
              continue;
            const kind = Math.random() < 0.5 ? "goblin" : "slime";
            const hp =
              kind === "goblin"
                ? between(5, 7) + Math.floor(state.level / 2)
                : between(6, 9) + Math.floor(state.level / 2);
            const atk = kind === "goblin" ? [1, 4] : [1, 3];
            state.enemies.push({ x, y, hp, max: hp, kind, atk });
          }
          // ground loot
          const potionCount = between(2, 4);
          for (let i = 0; i < potionCount && floorCells.length; i++) {
            const { x, y } = floorCells.pop();
            if (
              (x === state.player.x && y === state.player.y) ||
              state.map[y][x] !== 0
            )
              continue;
            state.items.push({ x, y, type: "potion" });
          }
          const foodCount = between(2, 4);
          for (let i = 0; i < foodCount && floorCells.length; i++) {
            const { x, y } = floorCells.pop();
            state.items.push({
              x,
              y,
              type: "food",
              name: "ê±´ì¡° ì‹ëŸ‰",
              hunger: [35, 55],
            });
          }
          const gearCount = between(1, 2);
          for (let i = 0; i < gearCount && floorCells.length; i++) {
            const { x, y } = floorCells.pop();
            const isWeapon = Math.random() < 0.5;
            if (isWeapon) {
              const w = randWeapon(state.level);
              state.items.push({
                x,
                y,
                type: "weapon",
                name: w.name,
                dmg: w.dmg,
              });
            } else {
              const a = randArmor(state.level);
              state.items.push({
                x,
                y,
                type: "armor",
                name: a.name,
                def: a.def,
              });
            }
          }

          // traps (hidden)
          const trapCount = between(
            2 + Math.floor(state.level / 2),
            4 + Math.floor(state.level / 2)
          );
          for (let i = 0; i < trapCount && floorCells.length; i++) {
            const { x, y } = floorCells.pop();
            if (x === state.player.x && y === state.player.y) continue;
            state.traps.push({
              x,
              y,
              armed: true,
              seen: false,
              kind: "spike",
              dmg: [3, 8],
            });
          }

          state.msgs = [];
          log(`ì§€í•˜ ${state.level}ì¸µì— ì§„ì…í–ˆìŠµë‹ˆë‹¤.`);
          computeFOV();
        }

        function connect(a, b) {
          let x = a.cx,
            y = a.cy;
          while (x !== b.cx) {
            state.map[y][x] = 0;
            x += x < b.cx ? 1 : -1;
          }
          while (y !== b.cy) {
            state.map[y][x] = 0;
            y += y < b.cy ? 1 : -1;
          }
          state.map[b.cy][b.cx] = 0;
        }

        function shuffle(arr) {
          for (let i = arr.length - 1; i > 0; i--) {
            const j = rnd(i + 1);
            [arr[i], arr[j]] = [arr[j], arr[i]];
          }
        }
        function dist(x1, y1, x2, y2) {
          const dx = x2 - x1,
            dy = y2 - y1;
          return Math.abs(dx) + Math.abs(dy);
        }
        function pickWeighted(arr, key) {
          const sum = arr.reduce((s, o) => s + (o[key] || 1), 0);
          let t = Math.random() * sum;
          for (const o of arr) {
            t -= o[key] || 1;
            if (t <= 0) return deepCopy(o);
          }
          return deepCopy(arr[arr.length - 1]);
        }
        function randWeapon(lv) {
          const cap = Math.min(3, 1 + Math.floor((lv + 1) / 2));
          return pickWeighted(
            WEAPONS.filter((w) => w.tier <= cap),
            "w"
          );
        }
        function randArmor(lv) {
          const cap = Math.min(3, 1 + Math.floor((lv + 1) / 2));
          return pickWeighted(
            ARMORS.filter((a) => a.tier <= cap),
            "w"
          );
        }

        // ===== Field of View =====
        function computeFOV() {
          const W = state.w,
            H = state.h,
            px = state.player.x,
            py = state.player.y;
          for (let y = 0; y < H; y++)
            for (let x = 0; x < W; x++) state.visible[y][x] = false;
          const r = FOV_RADIUS;
          for (let y = py - r; y <= py + r; y++) {
            for (let x = px - r; x <= px + r; x++) {
              if (!inBounds(x, y)) continue;
              const dx = x - px,
                dy = y - py;
              if (dx * dx + dy * dy > r * r) continue;
              if (lineOfSight(px, py, x, y)) {
                state.visible[y][x] = true;
                state.seen[y][x] = true;
              }
            }
          }
        }
        function lineOfSight(x0, y0, x1, y1) {
          let dx = Math.abs(x1 - x0),
            sx = x0 < x1 ? 1 : -1;
          let dy = -Math.abs(y1 - y0),
            sy = y0 < y1 ? 1 : -1;
          let err = dx + dy,
            x = x0,
            y = y0;
          while (true) {
            if (x === x1 && y === y1) return true;
            const e2 = 2 * err;
            if (e2 >= dy) {
              err += dy;
              x += sx;
            }
            if (e2 <= dx) {
              err += dx;
              y += sy;
            }
            if (!inBounds(x, y) || isWall(x, y)) return false;
          }
        }

        // ===== Entity helpers =====
        const isWall = (x, y) => state.map[y][x] === 1;
        const isFloorish = (x, y) =>
          state.map[y][x] === 0 || state.map[y][x] === 2;
        const stairsAt = (x, y) => state.map[y][x] === 2;
        const enemyAt = (x, y) =>
          state.enemies.find((e) => e.x === x && e.y === y);
        const itemAt = (x, y) =>
          state.items.find((it) => it.x === x && it.y === y);
        const occupied = (x, y) =>
          !!enemyAt(x, y) || (state.player.x === x && state.player.y === y);
        const trapAt = (x, y) =>
          state.traps.find((t) => t.x === x && t.y === y);

        // ===== Combat helpers =====
        function playerDamageRoll() {
          let base = between(state.player.atk[0], state.player.atk[1]);
          const w = state.equip.weapon;
          if (w) base += between(w.dmg[0], w.dmg[1]);
          return base;
        }
        function playerDefense() {
          return state.equip.armor ? state.equip.armor.def : 0;
        }

        // ===== Turn system =====
        function tryMove(dx, dy) {
          if (state.over || state.invOpen) return;
          if (!dx && !dy) return endTurn();
          const nx = clamp(state.player.x + dx, 0, state.w - 1);
          const ny = clamp(state.player.y + dy, 0, state.h - 1);
          if (!isFloorish(nx, ny)) {
            log("ë²½ì— ë§‰í˜”ìŠµë‹ˆë‹¤.", true);
            return;
          }

          const foe = enemyAt(nx, ny);
          if (foe) {
            attack(state.player, foe, "ë‹¹ì‹ ", foeName(foe));
            if (foe.hp <= 0) {
              const xp = expFor(foe);
              log(`${foeName(foe)}ì„(ë¥¼) ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤! (+${xp} EXP)`);
              state.enemies = state.enemies.filter((e) => e !== foe);
              gainExp(xp);
            }
            endTurn();
            return;
          }

          state.player.x = nx;
          state.player.y = ny;

          // trap check (trigger on step if armed)
          const t = trapAt(nx, ny);
          if (t && t.armed) {
            const dmg = between(t.dmg[0], t.dmg[1]);
            state.player.hp -= dmg;
            t.armed = false;
            t.seen = true;
            log(`í•¨ì • ì‘ë™! ê°€ì‹œ í•¨ì •ì— ${dmg} í”¼í•´ë¥¼ ì…ì—ˆìŠµë‹ˆë‹¤.`, true);
            checkGameOver();
          }

          const it = itemAt(nx, ny);
          if (it) {
            pickupItem(it);
            state.items = state.items.filter((o) => o !== it);
          }
          if (stairsAt(nx, ny))
            log("ê³„ë‹¨ ìœ„ì— ì„°ìŠµë‹ˆë‹¤. ë‹¤ìŒ ì¸µìœ¼ë¡œ ë‚´ë ¤ê°€ë ¤ë©´ '>' í‚¤.");
          endTurn();
        }

        function pickupItem(it) {
          if (it.type === "potion") {
            state.inv.push({ type: "potion", name: "ì²´ë ¥ ë¬¼ì•½" });
            log("ì²´ë ¥ ë¬¼ì•½ì„ ì£¼ì› ìŠµë‹ˆë‹¤. (ë³´ìœ  " + count("potion") + ")");
          } else if (it.type === "weapon") {
            state.inv.push({ type: "weapon", name: it.name, dmg: it.dmg });
            log(`ë¬´ê¸° ${it.name} ì„(ë¥¼) ì£¼ì› ìŠµë‹ˆë‹¤.`);
          } else if (it.type === "armor") {
            state.inv.push({ type: "armor", name: it.name, def: it.def });
            log(`ë°©ì–´êµ¬ ${it.name} ì„(ë¥¼) ì£¼ì› ìŠµë‹ˆë‹¤.`);
          } else if (it.type === "food") {
            state.inv.push({ type: "food", name: it.name, hunger: it.hunger });
            log(`ìŒì‹ ${it.name} ì„(ë¥¼) ì£¼ì› ìŠµë‹ˆë‹¤.`);
          }
          renderInventory();
        }

        function count(type) {
          return state.inv.filter((i) => i.type === type).length;
        }

        function endTurn() {
          // Hunger tick
          if (!state.over) {
            state.player.hunger = clamp(state.player.hunger - 1, 0, HUNGER_MAX);
            if (state.player.hunger === 0) {
              state.player.hp -= 1;
              log("êµ¶ì£¼ë¦¼ìœ¼ë¡œ 1 í”¼í•´ë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤!", true);
              checkGameOver();
            } else if (state.player.hunger === HUNGER_WARN) {
              log("ë°°ê°€ ê³ íŒŒì§€ê¸° ì‹œì‘í•©ë‹ˆë‹¤â€¦ (ìŒì‹ì„ ì°¾ìœ¼ì„¸ìš”)");
            }
          }

          computeFOV();
          enemiesAct();
          computeFOV();
          render();
          updateHUD();
          checkGameOver();
        }

        function enemiesAct() {
          for (const e of state.enemies) {
            if (e.hp <= 0) continue;
            const d = dist(e.x, e.y, state.player.x, state.player.y);
            let moved = false;
            if (d === 1) {
              attack(e, state.player, foeName(e), "ë‹¹ì‹ ");
              moved = true;
            } else if (
              d <= FOV_RADIUS &&
              lineOfSight(e.x, e.y, state.player.x, state.player.y)
            ) {
              const step = nextStepTowards(
                { x: e.x, y: e.y },
                { x: state.player.x, y: state.player.y }
              );
              if (step && !occupied(step.x, step.y)) {
                e.x = step.x;
                e.y = step.y;
                moved = true;
              }
            }
            if (!moved) {
              const dirs = [
                [1, 0],
                [-1, 0],
                [0, 1],
                [0, -1],
              ];
              shuffle(dirs);
              for (const [dx, dy] of dirs) {
                const nx = e.x + dx,
                  ny = e.y + dy;
                if (
                  inBounds(nx, ny) &&
                  isFloorish(nx, ny) &&
                  !occupied(nx, ny)
                ) {
                  e.x = nx;
                  e.y = ny;
                  break;
                }
              }
            }
          }
        }

        function expFor(e) {
          const base = e.kind === "goblin" ? 9 : 7;
          return base + Math.max(0, state.level - 1) * 2; // ì¸µì´ ê¹Šì„ìˆ˜ë¡ EXP ì¦ê°€
        }

        function gainExp(x) {
          state.player.exp += x;
          while (state.player.exp >= state.player.next) {
            state.player.exp -= state.player.next;
            levelUp();
          }
          updateHUD();
        }

        function levelUp() {
          state.player.ply += 1;
          const hpGain = between(3, 5);
          state.player.max += hpGain;
          state.player.hp = state.player.max;
          if (state.player.ply % 2 === 0) state.player.atk[0] += 1;
          state.player.atk[1] += 1;
          state.player.next = nextExp(state.player.ply);
          log(
            `ë ˆë²¨ ì—…! Lv ${state.player.ply} (ìµœëŒ€ HP +${hpGain}, ê³µê²©ë ¥ ê°•í™”)`,
            true
          );
        }

        function attack(att, def, aname, dname) {
          let dmg;
          if (att === state.player) dmg = playerDamageRoll();
          else dmg = between(att.atk[0], att.atk[1]);
          if (def === state.player) dmg = Math.max(1, dmg - playerDefense());
          def.hp -= dmg;
          log(`${aname} â†’ ${dname} ${dmg} í”¼í•´`, def === state.player);
        }

        function foeName(e) {
          return e.kind === "goblin" ? "ë„ì  ê³ ë¸”ë¦°" : "ëˆì í•œ ìŠ¬ë¼ì„";
        }

        function nextStepTowards(start, goal) {
          const W = state.w,
            H = state.h;
          const q = [start];
          const came = Array.from({ length: H }, () => Array(W).fill(null));
          came[start.y][start.x] = { x: -1, y: -1 };
          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
          ];
          while (q.length) {
            const cur = q.shift();
            if (cur.x === goal.x && cur.y === goal.y) break;
            for (const [dx, dy] of dirs) {
              const nx = cur.x + dx,
                ny = cur.y + dy;
              if (!inBounds(nx, ny) || !isFloorish(nx, ny)) continue;
              if (came[ny][nx]) continue;
              if (occupied(nx, ny) && !(nx === goal.x && ny === goal.y))
                continue; // allow goal tile
              came[ny][nx] = cur;
              q.push({ x: nx, y: ny });
            }
          }
          if (!came[goal.y] || !came[goal.y][goal.x]) return null;
          let cx = goal.x,
            cy = goal.y;
          let prev = came[cy][cx];
          while (prev && !(prev.x === start.x && prev.y === start.y)) {
            cx = prev.x;
            cy = prev.y;
            prev = came[cy][cx];
          }
          return { x: cx, y: cy };
        }

        // ===== Consumables & Equipment =====
        function consumePotion() {
          const idx = state.inv.findIndex((i) => i.type === "potion");
          if (idx < 0) {
            log("ë¬¼ì•½ì´ ì—†ìŠµë‹ˆë‹¤.", true);
            return false;
          }
          const heal = between(6, 10);
          state.inv.splice(idx, 1);
          state.player.hp = clamp(state.player.hp + heal, 0, state.player.max);
          log(
            `ë¬¼ì•½ì„ ë§ˆì…” ${heal} íšŒë³µí–ˆìŠµë‹ˆë‹¤. (HP ${state.player.hp}/${state.player.max})`
          );
          renderInventory();
          return true;
        }

        function consumeFood() {
          const idx = state.inv.findIndex((i) => i.type === "food");
          if (idx < 0) {
            log("ìŒì‹ì´ ì—†ìŠµë‹ˆë‹¤.", true);
            return false;
          }
          const it = state.inv[idx];
          const gain = between(it.hunger[0], it.hunger[1]);
          state.inv.splice(idx, 1);
          const before = state.player.hunger;
          state.player.hunger = clamp(
            state.player.hunger + gain,
            0,
            HUNGER_MAX
          );
          log(
            `ìŒì‹ì„ ë¨¹ì—ˆìŠµë‹ˆë‹¤. ë°°ê³ í”” +${state.player.hunger - before} (í˜„ì¬ ${
              state.player.hunger
            }/${HUNGER_MAX})`
          );
          renderInventory();
          return true;
        }

        function equipItem(item) {
          if (item.type === "weapon") {
            const prev = state.equip.weapon;
            state.equip.weapon = { name: item.name, dmg: item.dmg };
            if (prev)
              state.inv.push({
                type: "weapon",
                name: prev.name,
                dmg: prev.dmg,
              });
            log(`ë¬´ê¸° ì¥ì°©: ${item.name}`);
          } else if (item.type === "armor") {
            const prev = state.equip.armor;
            state.equip.armor = { name: item.name, def: item.def };
            if (prev)
              state.inv.push({ type: "armor", name: prev.name, def: prev.def });
            log(`ë°©ì–´êµ¬ ì¥ì°©: ${item.name}`);
          }
          renderInventory();
        }

        function useInvIndex(idx) {
          if (idx < 0 || idx >= state.inv.length) return;
          const item = state.inv[idx];
          if (item.type === "potion") {
            state.inv.splice(idx, 1);
            const heal = between(6, 10);
            state.player.hp = clamp(
              state.player.hp + heal,
              0,
              state.player.max
            );
            log(
              `ë¬¼ì•½ì„ ë§ˆì…” ${heal} íšŒë³µí–ˆìŠµë‹ˆë‹¤. (HP ${state.player.hp}/${state.player.max})`
            );
            renderInventory();
            endTurn();
          } else if (item.type === "weapon" || item.type === "armor") {
            state.inv.splice(idx, 1);
            equipItem(item);
            endTurn();
          } else if (item.type === "food") {
            state.inv.splice(idx, 1);
            const gain = between(item.hunger[0], item.hunger[1]);
            const before = state.player.hunger;
            state.player.hunger = clamp(
              state.player.hunger + gain,
              0,
              HUNGER_MAX
            );
            log(
              `ìŒì‹ì„ ë¨¹ì—ˆìŠµë‹ˆë‹¤. ë°°ê³ í”” +${
                state.player.hunger - before
              } (í˜„ì¬ ${state.player.hunger}/${HUNGER_MAX})`
            );
            renderInventory();
            endTurn();
          }
        }

        function drinkPotion() {
          if (!state.over && consumePotion()) endTurn();
        }
        function eatFood() {
          if (!state.over && consumeFood()) endTurn();
        }

        function descend() {
          if (state.over) return;
          if (!stairsAt(state.player.x, state.player.y)) {
            log("ì—¬ê¸°ëŠ” ê³„ë‹¨ì´ ì•„ë‹™ë‹ˆë‹¤.", true);
            return;
          }
          if (state.level >= MAX_LEVEL) {
            log("ë‹¹ì‹ ì€ ìµœì‹¬ë¶€ì˜ ë¹›ì„ ë³´ì•˜ìŠµë‹ˆë‹¤. ìŠ¹ë¦¬! ğŸ†");
            state.over = true;
            render();
            updateHUD();
            return;
          }
          state.level++;
          genLevel();
          render();
          updateHUD();
        }

        function checkGameOver() {
          if (state.player.hp > 0) return;
          state.player.hp = 0;
          log("ë‹¹ì‹ ì€ ì“°ëŸ¬ì¡ŒìŠµë‹ˆë‹¤... R í‚¤ë¡œ ì¬ì‹œì‘í•˜ì„¸ìš”.", true);
          state.over = true;
        }

        // ===== Rendering =====
        function updateHUD() {
          const p = state.player;
          const wName = state.equip.weapon ? state.equip.weapon.name : "-";
          const aName = state.equip.armor ? state.equip.armor.name : "-";
          const hungerState =
            p.hunger === 0
              ? "êµ¶ì£¼ë¦¼"
              : p.hunger <= HUNGER_WARN
              ? "í—ˆê¸°"
              : "ì–‘í˜¸";
          hudEl.innerHTML = `ì¸µìˆ˜ <b>${state.level}</b> Â· HP <b>${p.hp}/${
            p.max
          }</b> Â· í¬ì…˜ <b>${count("potion")}</b> Â· ìŒì‹ <b>${count(
            "food"
          )}</b> Â· ì  <b>${state.enemies.length}</b> Â· Lv <b>${
            p.ply
          }</b> (EXP ${p.exp}/${p.next}) Â· ë°°ê³ í”” <b>${
            p.hunger
          }/${HUNGER_MAX}</b> (${hungerState}) Â· ë¬´ê¸° <b>${escapeHtml(
            wName
          )}</b> Â· ë°©ì–´êµ¬ <b>${escapeHtml(aName)}</b>`;
        }

        function drawTile(x, y, color) {
          const s = state.tileSize;
          ctx.fillStyle = color;
          ctx.fillRect(x * s, y * s, s, s);
        }

        function render() {
          const s = state.tileSize;
          canvas.width = state.w * s;
          canvas.height = state.h * s;
          ctx.fillStyle = COLORS.void;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          for (let y = 0; y < state.h; y++) {
            for (let x = 0; x < state.w; x++) {
              const seen = state.seen[y][x],
                vis = state.visible[y][x];
              let base = COLORS.void;
              if (state.map[y][x] === 1)
                base = seen ? COLORS.wall : COLORS.void;
              else
                base = vis
                  ? COLORS.floor
                  : seen
                  ? COLORS.floorSeen
                  : COLORS.void;
              drawTile(x, y, base);
              if (state.map[y][x] === 2 && (vis || seen))
                drawGlyph(x, y, ">", COLORS.stairs);
            }
          }
          for (const it of state.items) {
            if (state.visible[it.y][it.x])
              drawGlyph(it.x, it.y, itemGlyph(it), itemColor(it));
          }
          // draw traps only after revealed
          for (const t of state.traps) {
            if (t.seen && state.visible[t.y][t.x])
              drawGlyph(t.x, t.y, "^", COLORS.enemy);
          }
          for (const e of state.enemies) {
            if (state.visible[e.y][e.x])
              drawGlyph(
                e.x,
                e.y,
                e.kind === "goblin" ? "g" : "s",
                COLORS.enemy
              );
          }
          drawGlyph(state.player.x, state.player.y, "@", COLORS.player);
          ctx.strokeStyle = "#0b1220";
          ctx.lineWidth = 2;
          ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
        }

        function itemGlyph(it) {
          return it.type === "potion"
            ? "!"
            : it.type === "weapon"
            ? ")"
            : it.type === "armor"
            ? "["
            : "%";
        }
        function itemColor(it) {
          return it.type === "potion"
            ? COLORS.potion
            : it.type === "food"
            ? COLORS.food
            : COLORS.gear;
        }

        function drawGlyph(x, y, ch, color) {
          const s = state.tileSize;
          const px = x * s,
            py = y * s;
          ctx.fillStyle = color;
          ctx.font = `${Math.floor(
            s * 0.9
          )}px ui-monospace, Consolas, monospace`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(ch, px + s / 2, py + s / 2 + 1);
        }

        function resize() {
          const pad = 24;
          const maxW = Math.min(window.innerWidth - pad * 2, 1100 - pad * 2);
          const maxH = window.innerHeight - 220;
          const tile = Math.floor(Math.min(maxW / VIEW_W, maxH / VIEW_H));
          state.tileSize = clamp(tile, 16, 32);
          render();
        }
        window.addEventListener("resize", resize);

        // ===== Inventory UI =====
        function toggleInventory(force) {
          if (typeof force === "boolean") state.invOpen = force;
          else state.invOpen = !state.invOpen;
          invEl.hidden = !state.invOpen;
          renderInventory();
        }
        function renderInventory() {
          if (invEl.hidden) return;
          const rows = state.inv
            .map((it, i) => {
              let meta = "";
              if (it.type === "potion") meta = "HP +6~10";
              else if (it.type === "weapon")
                meta = `í”¼í•´ +${it.dmg[0]}~+${it.dmg[1]}`;
              else if (it.type === "armor") meta = `ë°©ì–´ +${it.def}`;
              else if (it.type === "food")
                meta = `ë°°ê³ í”” +${it.hunger[0]}~+${it.hunger[1]}`;
              const icon =
                it.type === "potion"
                  ? "!"
                  : it.type === "weapon"
                  ? ")"
                  : it.type === "armor"
                  ? "["
                  : "%";
              const name =
                it.name || (it.type === "potion" ? "ì²´ë ¥ ë¬¼ì•½" : "ì‹ëŸ‰");
              return `<div class="item"><div class="idx">${
                i + 1
              }</div><div class="name">${escapeHtml(
                icon + " " + name
              )}</div><div class="meta">${meta}</div></div>`;
            })
            .join("");
          invBody.innerHTML =
            rows ||
            '<div class="item"><div class="name">(ë¹„ì–´ ìˆìŒ)</div></div>';
        }

        // ===== Messaging =====
        function log(msg, danger = false) {
          state.msgs.unshift({ t: msg, danger });
          state.msgs = state.msgs.slice(0, LOG_LINES);
          logEl.innerHTML = state.msgs
            .map(
              (m, i) =>
                `<div class="msg ${i > 1 ? "dim" : ""}" style="color:${
                  m.danger ? COLORS.enemy : COLORS.text
                }">${escapeHtml(m.t)}</div>`
            )
            .join("");
        }
        function escapeHtml(s) {
          return (s + "").replace(
            /[&<>"]/g,
            (c) =>
              ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" }[c])
          );
        }

        // ===== Input =====
        window.addEventListener(
          "keydown",
          (e) => {
            if (e.repeat) return;
            if (state.invOpen) {
              if (e.key === "Escape" || e.key === "i" || e.key === "I") {
                toggleInventory(false);
                e.preventDefault();
                return;
              }
              if (/^[1-9]$/.test(e.key)) {
                useInvIndex(parseInt(e.key, 10) - 1);
                e.preventDefault();
                return;
              }
              return; // ì¸ë²¤í† ë¦¬ ì—´ë¦° ë™ì•ˆ ì´ë™ ë“± ì°¨ë‹¨
            }
            if (e.key in keyDirs) {
              const [dx, dy] = keyDirs[e.key];
              tryMove(dx, dy);
              e.preventDefault();
              return;
            }
            if (e.key === ".") {
              endTurn();
              e.preventDefault();
              return;
            }
            if (e.key === "q" || e.key === "Q") {
              drinkPotion();
              e.preventDefault();
              return;
            }
            if (e.key === "f" || e.key === "F") {
              eatFood();
              e.preventDefault();
              return;
            }
            if (e.key === "i" || e.key === "I") {
              toggleInventory(true);
              e.preventDefault();
              return;
            }
            if (e.key === ">") {
              descend();
              e.preventDefault();
              return;
            }
            if (e.key === "r" || e.key === "R") {
              restart();
              e.preventDefault();
              return;
            }
          },
          { passive: false }
        );

        // ===== Start / Restart =====
        function restart() {
          state.level = 1;
          state.player = {
            x: 0,
            y: 0,
            hp: START_HP,
            max: START_HP,
            atk: [2, 6],
            ply: 1,
            exp: 0,
            next: nextExp(1),
            hunger: HUNGER_MAX,
          };
          state.equip = { weapon: null, armor: null };
          state.enemies = [];
          state.items = [];
          state.inv = [];
          state.over = false;
          state.invOpen = false;
          invEl.hidden = true;
          state.traps = [];
          genLevel();
          updateHUD();
          render();
          renderInventory();
        }

        // ===== Boot =====
        restart();
        resize();
      })();
    </script>
  </body>
</html>
