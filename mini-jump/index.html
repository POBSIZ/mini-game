<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>3D 점프맵 — 단일 HTML</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0b0f14;
        color: #e9f2ff;
        font-family: system-ui, Segoe UI, Roboto, Apple SD Gothic Neo,
          Malgun Gothic, sans-serif;
      }
      #gl {
        position: fixed;
        inset: 0;
        display: block;
        width: 100%;
        height: 100%;
      }
      .hud {
        position: fixed;
        top: 12px;
        left: 12px;
        right: 12px;
        display: flex;
        gap: 12px;
        align-items: center;
        z-index: 3;
        pointer-events: none;
      }
      .pill {
        background: rgba(8, 14, 24, 0.72);
        border: 1px solid rgba(129, 171, 255, 0.2);
        backdrop-filter: blur(6px);
        padding: 8px 12px;
        border-radius: 999px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
      }
      .hud .spacer {
        flex: 1;
      }
      .btn {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 4;
      }
      .card {
        pointer-events: auto;
        background: rgba(12, 18, 28, 0.88);
        border: 1px solid rgba(129, 171, 255, 0.25);
        padding: 20px 22px;
        border-radius: 20px;
        max-width: 560px;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.45);
      }
      .card h1 {
        margin: 0 0 6px;
        font-weight: 800;
        letter-spacing: 0.3px;
      }
      .card p {
        margin: 6px 0 0;
        opacity: 0.9;
        line-height: 1.5;
      }
      .badge {
        display: inline-block;
        margin-top: 10px;
        padding: 6px 10px;
        border-radius: 999px;
        background: #102038;
        border: 1px solid rgba(120, 170, 255, 0.25);
        font-size: 12px;
      }
      .toast {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(14, 22, 36, 0.9);
        border: 1px solid rgba(129, 171, 255, 0.25);
        padding: 10px 14px;
        border-radius: 12px;
        opacity: 0;
        transition: opacity 0.3s, transform 0.3s;
        z-index: 5;
      }
      .toast.show {
        opacity: 1;
        transform: translateX(-50%) translateY(-6px);
      }
      a {
        color: #a7c5ff;
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>
    <div class="hud">
      <div class="pill" id="status">⏱️ 00:00.0</div>
      <div class="pill" id="best">🏁 BEST — 없음</div>
      <div class="spacer"></div>
      <div class="pill">
        WASD 이동 · 스페이스 점프 · Shift 달리기 · R 체크포인트 리셋 · N
        처음부터
      </div>
    </div>
    <div class="btn" id="startUI">
      <div class="card">
        <h1>3D 점프맵</h1>
        <p>
          화면을 <b>클릭</b>해 마우스를 잠그고 시작하세요. <br />플랫폼을 점프해
          골드 블록까지 도달하면 클리어!
        </p>
        <div class="badge">PC · 키보드/마우스 전용</div>
      </div>
    </div>
    <div class="toast" id="toast"></div>
    <script>
      (() => {
        /*** ———————— WebGL 최소 렌더러 ———————— ***/
        const canvas = document.getElementById("gl");
        const gl = canvas.getContext("webgl", {
          antialias: true,
          alpha: false,
        });
        if (!gl) {
          alert("WebGL을 지원하지 않는 브라우저입니다.");
          return;
        }
        const DPR = Math.min(2, window.devicePixelRatio || 1);
        function resize() {
          const w = Math.max(1, canvas.clientWidth);
          const h = Math.max(1, canvas.clientHeight);
          canvas.width = Math.floor(w * DPR);
          canvas.height = Math.floor(h * DPR);
          gl.viewport(0, 0, canvas.width, canvas.height);
          aspect = canvas.width / canvas.height;
        }
        new ResizeObserver(resize).observe(canvas);

        // GLSL
        const vs = `
    attribute vec3 aPos;  
    attribute vec3 aNor;  
    uniform mat4 uProj, uView, uModel; 
    varying vec3 vN; 
    varying vec3 vW; 
    void main(){
      vec4 world = uModel * vec4(aPos,1.0);
      vW = world.xyz; 
      // 단순화를 위해 정규행렬 생략(축스케일만 사용)
      vN = mat3(uModel) * aNor; 
      gl_Position = uProj * uView * world; 
    }
  `;
        const fs = `
    precision mediump float; 
    varying vec3 vN; 
    varying vec3 vW; 
    uniform vec3 uColor; 
    uniform vec3 uLight; 
    void main(){
      vec3 N = normalize(vN);
      float diff = max(dot(N, normalize(-uLight)), 0.0);
      float ao = 0.85; // 살짝 어둡게
      float shade = ao + diff * 0.8; 
      vec3 c = uColor * shade; 
      gl_FragColor = vec4(c, 1.0);
    }
  `;
        function compile(type, src) {
          const s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
            throw gl.getShaderInfoLog(s);
          return s;
        }
        const prog = gl.createProgram();
        gl.attachShader(prog, compile(gl.VERTEX_SHADER, vs));
        gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
          throw gl.getProgramInfoLog(prog);
        gl.useProgram(prog);
        const loc = (n) => gl.getUniformLocation(prog, n);
        const aPos = gl.getAttribLocation(prog, "aPos");
        const aNor = gl.getAttribLocation(prog, "aNor");
        const uProj = loc("uProj"),
          uView = loc("uView"),
          uModel = loc("uModel"),
          uColor = loc("uColor"),
          uLight = loc("uLight");

        // 큐브 지오메트리 (정점 36개)
        const P = [
          // +X
          0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, -0.5, -0.5, 0.5,
          0.5, 0.5, 0.5, -0.5, 0.5,
          // -X
          -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, -0.5, -0.5, -0.5, 0.5,
          -0.5, 0.5, -0.5, -0.5, -0.5, -0.5,
          // +Y
          -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5,
          0.5, -0.5, -0.5, 0.5, -0.5,
          // -Y
          -0.5, -0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, -0.5, -0.5,
          0.5, -0.5, 0.5, -0.5, -0.5, 0.5,
          // +Z
          -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5,
          0.5, 0.5, -0.5, 0.5, 0.5,
          // -Z
          0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, -0.5,
          -0.5, 0.5, -0.5, 0.5, 0.5, -0.5,
        ];
        const N = [
          // +X
          1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,
          // -X
          -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0,
          // +Y
          0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
          // -Y
          0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,
          // +Z
          0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
          // -Z
          0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1,
        ];
        function buf(data, loc) {
          const b = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, b);
          gl.bufferData(
            gl.ARRAY_BUFFER,
            new Float32Array(data),
            gl.STATIC_DRAW
          );
          gl.enableVertexAttribArray(loc);
          gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 0, 0);
          return b;
        }
        buf(P, aPos);
        buf(N, aNor);

        // 행렬 유틸 (column-major)
        const M = {
          ident() {
            return new Float32Array([
              1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
            ]);
          },
          mul(a, b) {
            const o = new Float32Array(16);
            for (let r = 0; r < 4; r++) {
              for (let c = 0; c < 4; c++) {
                o[c * 4 + r] =
                  a[0 * 4 + r] * b[c * 4 + 0] +
                  a[1 * 4 + r] * b[c * 4 + 1] +
                  a[2 * 4 + r] * b[c * 4 + 2] +
                  a[3 * 4 + r] * b[c * 4 + 3];
              }
            }
            return o;
          },
          trans(x, y, z) {
            const m = this.ident();
            m[12] = x;
            m[13] = y;
            m[14] = z;
            return m;
          },
          scale(x, y, z) {
            const m = this.ident();
            m[0] = x;
            m[5] = y;
            m[10] = z;
            return m;
          },
          persp(fovy, aspect, near, far) {
            const f = 1 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            const m = new Float32Array(16);
            m[0] = f / aspect;
            m[5] = f;
            m[10] = (far + near) * nf;
            m[11] = -1;
            m[14] = 2 * far * near * nf;
            return m;
          },
          look(eye, center, up) {
            const zx = eye[0] - center[0],
              zy = eye[1] - center[1],
              zz = eye[2] - center[2];
            let zl = Math.hypot(zx, zy, zz);
            const zxN = zx / zl,
              zyN = zy / zl,
              zzN = zz / zl; // z
            let xx = up[1] * zzN - up[2] * zyN,
              xy = up[2] * zxN - up[0] * zzN,
              xz = up[0] * zyN - up[1] * zxN;
            const xl = Math.hypot(xx, xy, xz);
            xx /= xl;
            xy /= xl;
            xz /= xl; // x
            const yx = zyN * xz - zzN * xy,
              yy = zzN * xx - zxN * xz,
              yz = zxN * xy - zyN * xx; // y
            const m = this.ident();
            m[0] = xx;
            m[4] = yx;
            m[8] = zxN;
            m[1] = xy;
            m[5] = yy;
            m[9] = zyN;
            m[2] = xz;
            m[6] = yz;
            m[10] = zzN;
            m[12] = -(xx * eye[0] + xy * eye[1] + xz * eye[2]);
            m[13] = -(yx * eye[0] + yy * eye[1] + yz * eye[2]);
            m[14] = -(zxN * eye[0] + zyN * eye[1] + zzN * eye[2]);
            return m;
          },
        };

        // 전역 상태
        let aspect = 1;
        resize();
        const FOV = (70 * Math.PI) / 180;
        const PROJ_NEAR = 0.05,
          PROJ_FAR = 400;
        const proj = () => M.persp(FOV, aspect, PROJ_NEAR, PROJ_FAR);
        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0.06, 0.09, 0.13, 1);

        // 레벨 데이터 (AABB 박스)
        const PLATS = []; // {pos:[x,y,z], size:[sx,sy,sz], color:[r,g,b], type:"normal|checkpoint|goal"}
        function add(x, y, z, sx, sy, sz, type = "normal") {
          PLATS.push({
            pos: [x, y, z],
            size: [sx, sy, sz],
            color:
              type === "goal"
                ? [1.0, 0.85, 0.25]
                : type === "checkpoint"
                ? [0.45, 0.8, 1.0]
                : [0.55, 0.75, 0.95],
            type,
          });
        }
        // 시작 플랫폼
        add(0, 0, 0, 8, 1, 8, "checkpoint");
        // 코스 (앞쪽 -Z 방향)
        add(0, 2, -10, 4, 1, 4);
        add(2, 4, -18, 3, 1, 3);
        add(-2, 6, -26, 3, 1, 3, "checkpoint");
        add(0, 8, -34, 2.8, 1, 2.8);
        add(1.2, 10, -42, 2.6, 1, 2.6);
        add(-1.2, 12, -50, 2.4, 1, 2.4);
        add(0, 12, -58, 2.2, 1, 2.2);
        add(2, 11.5, -66, 2, 1, 2);
        add(0, 10.5, -74, 1.8, 1, 1.8);
        add(-2, 10, -82, 1.8, 1, 1.8, "checkpoint");
        add(-1, 10.5, -90, 1.6, 1, 1.6);
        add(1, 11, -98, 1.6, 1, 1.6);
        add(0, 12, -106, 1.8, 1, 1.8);
        add(0, 13, -114, 2, 1, 2);
        // 피니시
        add(0, 14, -122, 3, 1, 3, "goal");

        // 주변 장식 (바닥/벽)
        add(0, -2, -60, 200, 1, 200); // 아주 낮은 바닥 (보이지 않게)

        // 플레이어
        const player = {
          pos: [0, 2, 3], // 시작 위치
          vel: [0, 0, 0],
          size: [0.6, 1.8, 0.6],
          yaw: 0,
          pitch: 0,
          onGround: false,
          respawn: [0, 2, 3],
        };

        // 입력
        const keys = new Set();
        window.addEventListener("keydown", (e) => {
          keys.add(e.code);
          if (["KeyR", "KeyN"].includes(e.code)) e.preventDefault();
        });
        window.addEventListener("keyup", (e) => keys.delete(e.code));

        // 포인터락
        const startUI = document.getElementById("startUI");
        const toast = document.getElementById("toast");
        function showToast(msg) {
          toast.textContent = msg;
          toast.classList.add("show");
          setTimeout(() => toast.classList.remove("show"), 1200);
        }
        canvas.addEventListener("click", () => {
          if (document.pointerLockElement !== canvas)
            canvas.requestPointerLock();
        });
        document.addEventListener("pointerlockchange", () => {
          if (document.pointerLockElement === canvas) {
            startUI.style.display = "none";
            startGame();
          }
        });
        startUI.addEventListener(
          "click",
          () => {
            canvas.requestPointerLock();
          },
          { passive: true }
        );

        window.addEventListener("mousemove", (e) => {
          if (document.pointerLockElement === canvas) {
            const sens = 0.0025;
            player.yaw -= e.movementX * sens;
            player.pitch -= e.movementY * sens;
            player.pitch = Math.max(-1.553, Math.min(1.553, player.pitch)); // ~±89°
          }
        });

        // 시간/타이머
        let running = false,
          startTime = 0,
          elapsed = 0,
          finished = false;
        const statusEl = document.getElementById("status");
        const bestEl = document.getElementById("best");
        const BEST_KEY = "jumpmap_best_v1";
        const bestSaved = localStorage.getItem(BEST_KEY);
        if (bestSaved) {
          bestEl.textContent = "🏁 BEST — " + fmtTime(parseFloat(bestSaved));
        }
        function fmtTime(t) {
          const m = Math.floor(t / 60);
          const s = t % 60;
          return `${String(m).padStart(2, "0")}:${s
            .toFixed(1)
            .padStart(4, "0")}`;
        }

        function startGame() {
          if (!running) {
            running = true;
            finished = false;
            startTime = performance.now() / 1000;
          }
        }
        function resetToStart() {
          player.pos = [0, 2, 3];
          player.vel = [0, 0, 0];
          player.yaw = 0;
          player.pitch = 0;
          player.onGround = false;
          player.respawn = [0, 2, 3];
          running = false;
          finished = false;
          startUI.style.display = "";
          showToast("처음부터!");
        }
        function resetToCheckpoint() {
          player.pos = [...player.respawn];
          player.vel = [0, 0, 0];
          player.onGround = false;
          showToast("체크포인트로 복귀");
        }

        // 물리/충돌
        const GRAV = 24;
        const JUMP = 9;
        const SPEED = 6,
          SPRINT = 9;
        const AIR_CTRL = 0.18;
        const HEAD = 1.6; // 카메라 높이(플레이어 높이와 비슷)

        function moveAndCollide(dt) {
          // 입력 → 목표 속도
          let forward = [-Math.sin(player.yaw), 0, -Math.cos(player.yaw)];
          let right = [Math.cos(player.yaw), 0, -Math.sin(player.yaw)];
          function add(v, k, scale) {
            v[0] += k[0] * scale;
            v[1] += k[1] * scale;
            v[2] += k[2] * scale;
            return v;
          }
          let wish = [0, 0, 0];
          if (keys.has("KeyW")) add(wish, forward, 1);
          if (keys.has("KeyS")) add(wish, forward, -1);
          if (keys.has("KeyD")) add(wish, right, 1);
          if (keys.has("KeyA")) add(wish, right, -1);
          let wl = Math.hypot(wish[0], wish[2]);
          if (wl > 0) {
            wish[0] /= wl;
            wish[2] /= wl;
          }
          const maxSpd =
            keys.has("ShiftLeft") || keys.has("ShiftRight") ? SPRINT : SPEED;
          const accel = player.onGround ? 15 : 6; // 지면에서 더 빠르게 붙기
          player.vel[0] += wish[0] * accel * dt;
          player.vel[2] += wish[2] * accel * dt;
          // 수평 속도 제한
          const hspd = Math.hypot(player.vel[0], player.vel[2]);
          const cap = player.onGround ? maxSpd : maxSpd * AIR_CTRL;
          if (hspd > cap) {
            const scale = cap / hspd;
            player.vel[0] *= scale;
            player.vel[2] *= scale;
          }

          // 점프
          if (keys.has("Space") && player.onGround) {
            player.vel[1] = JUMP;
            player.onGround = false;
          }

          // 중력
          player.vel[1] -= GRAV * dt;

          // 마찰 (지면)
          if (player.onGround) {
            player.vel[0] *= 1 - 8 * dt;
            player.vel[2] *= 1 - 8 * dt;
          }

          // 축별 이동 & 충돌 해결
          sweepAxis(0, dt);
          sweepAxis(2, dt);
          let wasFalling = player.vel[1] < 0;
          sweepAxis(1, dt, wasFalling);

          // 낙하 리셋
          if (player.pos[1] < -12) {
            resetToCheckpoint();
          }
        }

        function sweepAxis(axis, dt, wasFalling = false) {
          const delta = player.vel[axis] * dt;
          player.pos[axis] += delta;
          const pMin = [
            player.pos[0] - player.size[0] / 2,
            player.pos[1],
            player.pos[2] - player.size[2] / 2,
          ];
          const pMax = [
            player.pos[0] + player.size[0] / 2,
            player.pos[1] + player.size[1],
            player.pos[2] + player.size[2] / 2,
          ];
          player.onGround = false;
          for (const b of PLATS) {
            const bMin = [
              b.pos[0] - b.size[0] / 2,
              b.pos[1] - b.size[1] / 2,
              b.pos[2] - b.size[2] / 2,
            ];
            const bMax = [
              b.pos[0] + b.size[0] / 2,
              b.pos[1] + b.size[1] / 2,
              b.pos[2] + b.size[2] / 2,
            ];
            if (
              pMax[0] > bMin[0] &&
              pMin[0] < bMax[0] &&
              pMax[1] > bMin[1] &&
              pMin[1] < bMax[1] &&
              pMax[2] > bMin[2] &&
              pMin[2] < bMax[2]
            ) {
              // 충돌! 축별 보정
              if (axis === 0) {
                // X
                if (delta > 0) {
                  const push = bMin[0] - pMax[0];
                  player.pos[0] += push;
                } else {
                  const push = bMax[0] - pMin[0];
                  player.pos[0] += push;
                }
                player.vel[0] = 0;
              } else if (axis === 2) {
                // Z
                if (delta > 0) {
                  const push = bMin[2] - pMax[2];
                  player.pos[2] += push;
                } else {
                  const push = bMax[2] - pMin[2];
                  player.pos[2] += push;
                }
                player.vel[2] = 0;
              } else {
                // Y
                if (delta > 0) {
                  const push = bMin[1] - pMax[1];
                  player.pos[1] += push;
                  player.vel[1] = 0;
                } else {
                  const push = bMax[1] - pMin[1];
                  player.pos[1] += push;
                  player.vel[1] = 0;
                  if (wasFalling) player.onGround = true;
                }
                // 체크포인트/골 처리는 Y 단계에서 판단 (접지 시점)
                if (b.type === "checkpoint" && wasFalling) {
                  player.respawn = [player.pos[0], bMax[1], player.pos[2]];
                  showToast("✅ 체크포인트 저장");
                }
                if (b.type === "goal" && wasFalling) {
                  finish();
                }
              }
              // AABB 갱신
              pMin[0] = player.pos[0] - player.size[0] / 2;
              pMax[0] = player.pos[0] + player.size[0] / 2;
              pMin[1] = player.pos[1];
              pMax[1] = player.pos[1] + player.size[1];
              pMin[2] = player.pos[2] - player.size[2] / 2;
              pMax[2] = player.pos[2] + player.size[2] / 2;
            }
          }
        }

        function finish() {
          if (finished) return;
          finished = true;
          running = false;
          const t = elapsed;
          const prev = parseFloat(localStorage.getItem(BEST_KEY) || "Infinity");
          if (!isFinite(prev) || t < prev) {
            localStorage.setItem(BEST_KEY, String(t));
            bestEl.textContent = "🏁 BEST — " + fmtTime(t);
            showToast("🎉 신기록! " + fmtTime(t));
          } else showToast("클리어! 기록: " + fmtTime(t));
        }

        // 렌더
        const LIGHT_DIR = [-0.5, -1.0, -0.2];
        function draw() {
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          gl.useProgram(prog);
          gl.uniform3fv(uLight, LIGHT_DIR);
          gl.uniformMatrix4fv(uProj, false, proj());

          // 카메라
          const eye = [player.pos[0], player.pos[1] + HEAD, player.pos[2]];
          const dir = [
            -Math.sin(player.yaw) * Math.cos(player.pitch),
            Math.sin(player.pitch),
            -Math.cos(player.yaw) * Math.cos(player.pitch),
          ];
          const center = [eye[0] + dir[0], eye[1] + dir[1], eye[2] + dir[2]];
          const view = M.look(eye, center, [0, 1, 0]);
          gl.uniformMatrix4fv(uView, false, view);

          // 하늘(간단한 컬러 그라데이션 느낌: 멀리 큐브들 색으로 대체)

          // 박스 그리기
          for (const b of PLATS) {
            const model = M.mul(
              M.trans(b.pos[0], b.pos[1], b.pos[2]),
              M.scale(b.size[0], b.size[1], b.size[2])
            );
            gl.uniformMatrix4fv(uModel, false, model);
            gl.uniform3fv(uColor, b.color);
            gl.drawArrays(gl.TRIANGLES, 0, 36);
            // 골 블록 상단에 금 상자 추가
            if (b.type === "goal") {
              const topY = b.pos[1] + b.size[1] / 2 + 0.6;
              const model2 = M.mul(
                M.trans(b.pos[0], topY, b.pos[2]),
                M.scale(0.8, 0.8, 0.8)
              );
              gl.uniformMatrix4fv(uModel, false, model2);
              gl.uniform3fv(uColor, [1.0, 0.9, 0.4]);
              gl.drawArrays(gl.TRIANGLES, 0, 36);
            }
          }
        }

        // 루프
        let last = performance.now() / 1000;
        function loop() {
          const now = performance.now() / 1000;
          let dt = now - last;
          last = now;
          dt = Math.min(dt, 0.033);
          if (running && !finished) {
            elapsed = now - startTime;
          }
          statusEl.textContent = "⏱️ " + fmtTime(elapsed);

          // 입력 핸들
          if (keys.has("KeyR")) {
            keys.delete("KeyR");
            resetToCheckpoint();
          }
          if (keys.has("KeyN")) {
            keys.delete("KeyN");
            resetToStart();
          }

          // 업데이트
          if (running && !finished) {
            moveAndCollide(dt);
          }

          draw();
          requestAnimationFrame(loop);
        }
        loop();

        // 처음 로드 시 약간의 가이드 표시
        showToast("화면을 클릭해 시작하세요");
      })();
    </script>
  </body>
</html>
