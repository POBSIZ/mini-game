<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <title>레트로 플랫포머 — 한 파일 게임</title>
    <style>
      :root {
        --bg1: #0a0f1e;
        --bg2: #15233d;
        --hud: #ffffff;
        --accent: #7dd3fc;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        background: radial-gradient(
          1200px 700px at 70% 20%,
          #1b2a4a 0%,
          var(--bg1) 35%,
          var(--bg2) 100%
        );
        color: var(--hud);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Pretendard,
          Apple SD Gothic Neo, Noto Sans KR, Arial, sans-serif;
        overflow: hidden;
      }
      #wrap {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      canvas {
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        background: transparent;
        box-shadow: 0 6px 32px rgba(0, 0, 0, 0.45);
        border-radius: 16px;
      }
      #ui {
        position: fixed;
        top: 12px;
        left: 12px;
        right: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        pointer-events: none;
        font-weight: 600;
        text-shadow: 0 2px 0 rgba(0, 0, 0, 0.4);
      }
      .pill {
        background: rgba(0, 0, 0, 0.35);
        padding: 8px 12px;
        border-radius: 999px;
        display: inline-flex;
        gap: 14px;
        align-items: center;
      }
      .pill small {
        opacity: 0.85;
      }
      .kbd {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 6px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        font-feature-settings: "tnum" on, "lnum" on;
      }

      /* Title / modal */
      #modal {
        position: fixed;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #card {
        width: min(92vw, 820px);
        border-radius: 18px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.08),
          rgba(255, 255, 255, 0.03)
        );
        border: 1px solid rgba(255, 255, 255, 0.2);
        box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
        padding: 28px;
        backdrop-filter: blur(10px);
        color: #fff;
      }
      #card h1 {
        margin: 0 0 4px;
        font-size: 28px;
        letter-spacing: 0.5px;
      }
      #card p {
        margin: 8px 0;
        opacity: 0.9;
      }
      #startBtn {
        margin-top: 14px;
        font-weight: 700;
        border: none;
        background: #34d399;
        color: #072b1d;
        padding: 12px 16px;
        border-radius: 12px;
        cursor: pointer;
      }

      /* Touch controls */
      #touch {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        display: none;
        justify-content: space-between;
        padding: 16px;
        gap: 16px;
      }
      .tbtn {
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.18);
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.35) inset;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 800;
      }
      .tpad {
        width: 200px;
        height: 120px;
        border-radius: 18px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      .tkey {
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.18);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 800;
      }

      @media (pointer: coarse) {
        #touch {
          display: flex;
        }
        #ui .pill:last-child {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="wrap">
      <canvas
        id="game"
        width="640"
        height="360"
        aria-label="플랫포머 게임 캔버스"
      ></canvas>
    </div>
    <div id="ui">
      <div class="pill" id="hudLeft">
        <span>❤️ <span id="lives">3</span></span>
        <span>🪙 <span id="coins">0</span></span>
        <span>⏱️ <span id="time">0.0</span>s</span>
      </div>
      <div class="pill">
        <small>
          이동 <span class="kbd">←</span><span class="kbd">→</span> /
          <span class="kbd">A</span><span class="kbd">D</span> · 점프
          <span class="kbd">Space</span>/<span class="kbd">W</span>/<span
            class="kbd"
            >↑</span
          >
          · 일시정지 <span class="kbd">P</span> · 재시작
          <span class="kbd">R</span>
        </small>
      </div>
    </div>

    <!-- Touch controls -->
    <div id="touch">
      <div class="tpad">
        <div class="tkey" id="tLeft">◀︎</div>
        <div class="tkey" id="tRight">▶︎</div>
      </div>
      <div class="tbtn" id="tJump">JUMP</div>
    </div>

    <!-- Title / help modal -->
    <div id="modal">
      <div id="card" role="dialog" aria-modal="true">
        <h1>레트로 플랫포머</h1>
        <p>
          한 파일(html)만 저장하면 바로 실행되는 간단한 "마리오 느낌"의 플랫포머
          게임입니다. 모든 그래픽은 코드로 그려집니다. (외부 에셋 없음)
        </p>
        <ul>
          <li>
            동전 모으기, 적 밟기, 가시/용암을 피해 골인 깃발에 도달하세요.
          </li>
          <li>키보드 또는 터치(모바일)로 플레이 가능.</li>
        </ul>
        <button id="startBtn">게임 시작</button>
      </div>
    </div>

    <script>
      (function () {
        "use strict";

        // === Canvas & Scaling ===
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        ctx.imageSmoothingEnabled = false;

        const VIRT_W = 640; // logical width
        const VIRT_H = 360; // logical height
        const TILE = 32; // tile size

        function fit() {
          const scale =
            Math.floor(
              Math.min(window.innerWidth / VIRT_W, window.innerHeight / VIRT_H)
            ) || 1;
          canvas.style.width = VIRT_W * scale + "px";
          canvas.style.height = VIRT_H * scale + "px";
        }
        window.addEventListener("resize", fit);
        fit();

        // === Input ===
        const input = {
          left: false,
          right: false,
          jump: false,
          pause: false,
          restart: false,
        };
        const keyMap = {
          ArrowLeft: "left",
          KeyA: "left",
          ArrowRight: "right",
          KeyD: "right",
          Space: "jump",
          ArrowUp: "jump",
          KeyW: "jump",
          KeyP: "pause",
          KeyR: "restart",
        };
        window.addEventListener("keydown", (e) => {
          const m = keyMap[e.code];
          if (m) {
            if (
              ["ArrowLeft", "ArrowRight", "Space", "ArrowUp"].includes(e.code)
            )
              e.preventDefault();
            input[m] = true;
          }
        });
        window.addEventListener("keyup", (e) => {
          const m = keyMap[e.code];
          if (m) {
            input[m] = false;
          }
        });

        // Touch controls
        const tLeft = document.getElementById("tLeft");
        const tRight = document.getElementById("tRight");
        const tJump = document.getElementById("tJump");
        function bindTouch(el, key) {
          const on = () => (input[key] = true);
          const off = () => (input[key] = false);
          ["pointerdown", "touchstart", "mousedown"].forEach((ev) =>
            el.addEventListener(ev, (e) => {
              e.preventDefault();
              on();
            })
          );
          [
            "pointerup",
            "pointercancel",
            "touchend",
            "mouseup",
            "mouseleave",
          ].forEach((ev) =>
            el.addEventListener(ev, (e) => {
              e.preventDefault();
              off();
            })
          );
        }
        bindTouch(tLeft, "left");
        bindTouch(tRight, "right");
        bindTouch(tJump, "jump");

        // === Level Generation ===
        const H = 12; // tiles high
        const W = 240; // tiles wide (long level!)
        let grid = buildLevel(W, H);

        function buildLevel(W, H) {
          // 2D array of chars
          const g = Array.from({ length: H }, () => Array(W).fill(" "));
          // Base ground: bottom 3 rows
          for (let y = H - 3; y < H; y++)
            for (let x = 0; x < W; x++) g[y][x] = "#";
          // Start & Flag
          g[H - 4][3] = "S";
          g[H - 4][W - 4] = "F";
          // Carve pits with lava every ~28 tiles
          for (let x = 20; x < W - 12; x += 28) {
            const w = 3 + ((x / 7) % 2 | 0); // 3 or 4 wide
            for (let i = 0; i < w; i++) {
              for (let y = H - 3; y < H; y++) g[y][x + i] = " ";
              g[H - 2][x + i] = "L";
              g[H - 1][x + i] = "L";
            }
            // add spikes at pit edges
            if (x - 1 > 0) g[H - 4][x - 1] = "^";
            // if (x + w < W) g[H - 4][x + w] = "^";
          }
          // Platforms and coins
          const platforms = [
            { x: 12, y: H - 6, len: 6 },
            { x: 26, y: H - 7, len: 5 },
            { x: 40, y: H - 8, len: 7 },
            { x: 58, y: H - 7, len: 6 },
            { x: 75, y: H - 6, len: 4 },
            { x: 92, y: H - 8, len: 8 },
            { x: 118, y: H - 7, len: 6 },
            { x: 140, y: H - 8, len: 7 },
            { x: 165, y: H - 7, len: 5 },
            { x: 188, y: H - 6, len: 6 },
            { x: 208, y: H - 7, len: 5 },
          ];
          for (const p of platforms) {
            for (let i = 0; i < p.len; i++) g[p.y][p.x + i] = "-";
            // coins above platforms
            for (let i = 1; i < p.len - 1; i += 2) g[p.y - 2][p.x + i] = "o";
          }
          // Ground coins rows
          for (let x = 6; x < W - 6; x += 9) {
            if (g[H - 4][x] === " " && g[H - 3][x] === "#") g[H - 5][x] = "o";
          }
          // Enemies on ground every ~22 tiles where safe
          for (let x = 18; x < W - 20; x += 22) {
            if (g[H - 4][x] === " " && g[H - 3][x] === "#") g[H - 4][x] = "x";
          }
          // Extra spikes
          for (let x = 34; x < W - 10; x += 37) {
            if (g[H - 4][x] === " " && g[H - 3][x] === "#") g[H - 4][x] = "^";
          }
          return g.map((row) => row.join(""));
        }

        // Helpers
        const isSolid = (c) => c === "#" || c === "-" || c === "^";
        const isHazard = (c) => c === "^" || c === "L";

        function getTile(x, y) {
          if (x < 0 || y < 0) return "#";
          const tx = x | 0,
            ty = y | 0; // already in tile coords
          if (ty >= grid.length || tx >= grid[0].length) return "#";
          return grid[ty][tx];
        }
        function setTile(x, y, ch) {
          if (y < 0 || y >= grid.length || x < 0 || x >= grid[0].length) return;
          const row = grid[y].split("");
          row[x] = ch;
          grid[y] = row.join("");
        }

        // === Entities ===
        function rectsOverlap(a, b) {
          return (
            a.x < b.x + b.w &&
            a.x + a.w > b.x &&
            a.y < b.y + b.h &&
            a.y + a.h > b.y
          );
        }

        const player = {
          x: 4 * TILE,
          y: 0,
          w: 22,
          h: 28,
          vx: 0,
          vy: 0,
          onGround: false,
          facing: 1,
          coyote: 0,
          jumpBuf: 0,
          invul: 0,
          alive: true,
          jumps: 0,
          airTime: 0,
          prevJump: false,
        };
        let lives = 3,
          coins = 0,
          gameTime = 0;

        const enemies = [];
        const coinsList = [];
        let startX = 4,
          startY = 0,
          flagRect = null;

        function parseLevel() {
          enemies.length = 0;
          coinsList.length = 0;
          flagRect = null;
          for (let y = 0; y < grid.length; y++) {
            for (let x = 0; x < grid[0].length; x++) {
              const c = grid[y][x];
              if (c === "S") {
                startX = x * TILE;
                startY = (y - 1) * TILE;
                setTile(x, y, " ");
              }
              if (c === "x") {
                enemies.push({
                  x: x * TILE + 4,
                  y: (y - 1) * TILE,
                  w: 24,
                  h: 26,
                  vx: 60 * (Math.random() < 0.5 ? 1 : -1),
                  vy: 0,
                  dir: 1,
                  alive: true,
                });
                setTile(x, y, " ");
              }
              if (c === "o") {
                coinsList.push({
                  x: x * TILE + 8,
                  y: y * TILE + 8,
                  w: 16,
                  h: 16,
                  t: Math.random() * Math.PI * 2,
                  got: false,
                });
                setTile(x, y, " ");
              }
              if (c === "F") {
                flagRect = {
                  x: x * TILE + 8,
                  y: (y - 3) * TILE,
                  w: 16,
                  h: 3 * TILE,
                };
                setTile(x, y, " ");
              }
            }
          }
          player.x = startX;
          player.y = startY;
          player.vx = 0;
          player.vy = 0;
          player.onGround = false;
          player.alive = true;
          player.invul = 0;
        }
        parseLevel();

        // === Physics ===
        const GRAV = 2000; // px/s^2
        const MAXS = 220; // run speed
        const ACCL = 1600; // accel
        const FRI_G = 1400; // ground friction
        const FRI_A = 200; // air friction
        const JUMP = 650; // jump velocity
        const COYOTE = 0.1; // seconds
        const JBUF = 0.12;
        const MAX_JUMPS = 2;
        const MIN_AIR = 0.1;

        // Camera
        let camX = 0;

        // Sounds (tiny WebAudio beeps)
        const AC =
          window.AudioContext || window.webkitAudioContext
            ? new (window.AudioContext || window.webkitAudioContext)()
            : null;
        function beep(type = "sine", freq = 440, dur = 0.08, vol = 0.05) {
          if (!AC) return;
          const t = AC.currentTime;
          const o = AC.createOscillator();
          const g = AC.createGain();
          o.type = type;
          o.frequency.value = freq;
          g.gain.value = vol;
          o.connect(g);
          g.connect(AC.destination);
          o.start(t);
          o.stop(t + dur);
          g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
        }

        function killPlayer() {
          if (player.invul > 0) return;
          lives--;
          player.invul = 1.0;
          player.vx = -player.facing * 120;
          player.vy = -420;
          beep("triangle", 160, 0.2, 0.08);
          if (lives < 0) {
            state = "gameover";
            showModal(
              "게임 오버",
              "<p>다시 도전해볼까요? <b>R</b> 키로 재시작.</p>"
            );
          } else state = "respawn";
        }

        function stompEnemy(e) {
          e.alive = false;
          player.vy = -JUMP * 0.6;
          coins += 1;
          beep("square", 720, 0.08, 0.06);
        }

        // Collision helpers (tile-based)
        function collideWorld(ent, dt) {
          // apply gravity
          ent.vy += GRAV * dt;

          // vertical move
          ent.y += ent.vy * dt;
          let x0 = Math.floor(ent.x / TILE),
            x1 = Math.floor((ent.x + ent.w - 1) / TILE);
          if (ent.vy > 0) {
            // falling: check below feet
            const yb = Math.floor((ent.y + ent.h - 1) / TILE);
            for (let tx = x0; tx <= x1; tx++) {
              const c = getTile(tx, yb);
              if (isHazard(c)) {
                killPlayer();
                break;
              }
              if (isSolid(c)) {
                ent.y = yb * TILE - ent.h;
                ent.vy = 0;
                ent.onGround = true;
                break;
              }
            }
          } else if (ent.vy < 0) {
            // jumping: head bump
            const yt = Math.floor(ent.y / TILE);
            for (let tx = x0; tx <= x1; tx++) {
              const c = getTile(tx, yt);
              if (isSolid(c)) {
                ent.y = (yt + 1) * TILE;
                ent.vy = 0; // question blocks could go here
                break;
              }
            }
          }

          // horizontal move
          ent.x += ent.vx * dt;
          x0 = Math.floor(ent.x / TILE);
          x1 = Math.floor((ent.x + ent.w - 1) / TILE);
          const y0 = Math.floor(ent.y / TILE),
            y1 = Math.floor((ent.y + ent.h - 1) / TILE);
          if (ent.vx > 0) {
            const xr = Math.floor((ent.x + ent.w - 1) / TILE);
            for (let ty = y0; ty <= y1; ty++) {
              const c = getTile(xr, ty);
              if (isHazard(c)) {
                killPlayer();
                break;
              }
              if (isSolid(c)) {
                ent.x = xr * TILE - ent.w;
                ent.vx = 0;
                break;
              }
            }
          } else if (ent.vx < 0) {
            const xl = Math.floor(ent.x / TILE);
            for (let ty = y0; ty <= y1; ty++) {
              const c = getTile(xl, ty);
              if (isHazard(c)) {
                killPlayer();
                break;
              }
              if (isSolid(c)) {
                ent.x = (xl + 1) * TILE;
                ent.vx = 0;
                break;
              }
            }
          }
        }

        // === Game State ===
        let state = "menu"; // 'menu'|'play'|'win'|'gameover'|'respawn'|'pause'

        const modal = document.getElementById("modal");
        const startBtn = document.getElementById("startBtn");
        startBtn.addEventListener("click", () => {
          closeModal();
          startGame();
        });
        function showModal(title, html) {
          modal.style.display = "flex";
          document.getElementById("card").innerHTML = `
        <h1>${title}</h1>
        ${html || ""}
        <button id="startBtn">계속</button>`;
          document.getElementById("startBtn").addEventListener("click", () => {
            closeModal();
            if (state === "menu" || state === "gameover" || state === "win")
              startGame();
            else state = "play";
          });
        }
        function closeModal() {
          modal.style.display = "none";
        }

        function startGame() {
          // Reset counters & level (but keep the same generated map)
          lives = 3;
          coins = 0;
          gameTime = 0;
          grid = buildLevel(W, H);
          parseLevel();
          state = "play";
          document.getElementById("lives").textContent = lives;
          document.getElementById("coins").textContent = coins;
          document.getElementById("time").textContent = "0.0";
          AC && AC.resume?.();
        }

        // === Loop ===
        let last = performance.now(),
          acc = 0;
        const FIXED = 1 / 60;
        function loop(t) {
          const dt = Math.min(0.1, (t - last) / 1000);
          last = t;
          acc += dt;
          while (acc >= FIXED) {
            step(FIXED);
            acc -= FIXED;
          }
          draw();
          requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        // === Step ===
        function step(dt) {
          if (state === "menu" || state === "gameover" || state === "win") {
            return;
          }

          if (input.pause) {
            input.pause = false;
            state = state === "pause" ? "play" : "pause";
          }
          if (state === "pause") {
            return;
          }
          if (input.restart) {
            input.restart = false;
            startGame();
            return;
          }

          gameTime += dt;
          document.getElementById("time").textContent = gameTime.toFixed(1);
          document.getElementById("lives").textContent = Math.max(0, lives);
          document.getElementById("coins").textContent = coins;

          // Player control
          const ax = (input.left ? -1 : 0) + (input.right ? 1 : 0);
          if (ax !== 0) {
            player.vx += ax * ACCL * dt;
            player.facing = ax > 0 ? 1 : -1;
          }
          // friction
          const fr = player.onGround ? FRI_G : FRI_A;
          if (ax === 0) {
            if (Math.abs(player.vx) < fr * dt) player.vx = 0;
            else player.vx -= Math.sign(player.vx) * fr * dt;
          }
          // clamp speed
          player.vx = Math.max(-MAXS, Math.min(MAXS, player.vx));

          const justPressed = input.jump && !player.prevJump; // 키를 새로 눌렀을 때만 버퍼 세팅

          // coyote & jump buffer
          if (player.onGround) player.coyote = COYOTE;
          else player.coyote = Math.max(0, player.coyote - dt);

          if (justPressed) player.jumpBuf = JBUF;
          else player.jumpBuf = Math.max(0, player.jumpBuf - dt);

          if (player.jumpBuf > 0) {
            if (player.onGround || player.coyote > 0) {
              // 1단 점프 (지상/코요테)
              player.vy = -JUMP;
              player.onGround = false;
              player.coyote = 0;
              player.jumpBuf = 0;
              player.jumps = 1;
              beep("square", 520, 0.07, 0.06);
            } else if (player.jumps < MAX_JUMPS && player.airTime > MIN_AIR) {
              // 2단 점프 — 최소 공중 시간 보장
              player.vy = -JUMP * 0.95;
              player.jumpBuf = 0;
              player.jumps++;
              beep("triangle", 700, 0.07, 0.06);
            }
          }

          // Physics & collisions
          player.onGround = false;
          collideWorld(player, dt);
          if (player.onGround) {
            player.jumps = 0;
            player.airTime = 0;
          } else {
            player.airTime += dt;
          }
          player.invul = Math.max(0, player.invul - dt);

          // World bounds
          const levelPxW = grid[0].length * TILE;
          player.x = Math.max(0, Math.min(levelPxW - player.w, player.x));

          // Coins pickup
          for (const c of coinsList) {
            if (
              !c.got &&
              rectsOverlap(player, { x: c.x, y: c.y, w: c.w, h: c.h })
            ) {
              c.got = true;
              coins++;
              beep("sine", 880, 0.09, 0.05);
            }
            c.t += dt * 6;
          }

          // Enemies update
          for (const e of enemies) {
            if (!e.alive) continue;
            // edge check: if next tile ahead is air, flip
            const aheadX =
              e.vx > 0
                ? Math.floor((e.x + e.w + 2) / TILE)
                : Math.floor((e.x - 2) / TILE);
            const feetY = Math.floor((e.y + e.h + 2) / TILE);
            const tileBelowAhead = getTile(aheadX, feetY);
            if (tileBelowAhead === " " || tileBelowAhead === "L") e.vx *= -1;
            // wall collision
            const sideX =
              e.vx > 0
                ? Math.floor((e.x + e.w + 1) / TILE)
                : Math.floor((e.x - 1) / TILE);
            const y0 = Math.floor(e.y / TILE),
              y1 = Math.floor((e.y + e.h - 1) / TILE);
            for (let ty = y0; ty <= y1; ty++) {
              if (isSolid(getTile(sideX, ty))) {
                e.vx *= -1;
                break;
              }
            }

            // Physics & collisions
            collideWorld(e, dt);

            // move
            e.x += e.vx * dt;

            // player vs enemy
            if (rectsOverlap(player, e) && e.alive) {
              const fromAbove = player.vy > 0 && player.y + player.h - e.y < 14;
              if (fromAbove) {
                stompEnemy(e);
              } else killPlayer();
            }
          }

          // Hazards overlap check (spikes/lava inside body)
          const tx0 = Math.floor(player.x / TILE),
            tx1 = Math.floor((player.x + player.w - 1) / TILE);
          const ty0 = Math.floor(player.y / TILE),
            ty1 = Math.floor((player.y + player.h - 1) / TILE);
          for (let ty = ty0; ty <= ty1; ty++) {
            for (let tx = tx0; tx <= tx1; tx++) {
              if (isHazard(getTile(tx, ty))) {
                killPlayer();
                break;
              }
            }
          }

          // Reaching flag
          if (flagRect && rectsOverlap(player, flagRect)) {
            state = "win";
            beep("sine", 660, 0.15, 0.06);
            beep("sine", 880, 0.25, 0.05);
            showModal(
              "클리어! 🎉",
              `<p><b>${gameTime.toFixed(
                1
              )}초</b> · 동전 <b>${coins}</b>개</p><p><b>R</b> 키로 재시작하거나, 계속을 눌러 다시 플레이하세요.</p>`
            );
          }

          // 키 엣지 갱신
          player.prevJump = input.jump;

          // Respawn flow
          if (state === "respawn") {
            // fall back to start after a brief delay
            respawnTimer -= dt;
            if (respawnTimer <= 0) {
              player.x = startX;
              player.y = startY;
              player.vx = 0;
              player.vy = 0;
              player.invul = 1.2;
              state = "play";
            }
          }
        }
        let respawnTimer = 0.7;

        // === Draw ===
        function draw() {
          // Camera follow
          const levelW = grid[0].length * TILE;
          const half = VIRT_W / 2;
          camX = Math.max(
            0,
            Math.min(levelW - VIRT_W, player.x + player.w / 2 - half)
          );

          // Sky (parallax)
          ctx.clearRect(0, 0, VIRT_W, VIRT_H);
          const skyGrad = ctx.createLinearGradient(0, 0, 0, VIRT_H);
          skyGrad.addColorStop(0, "#0b1530");
          skyGrad.addColorStop(1, "#09101f");
          ctx.fillStyle = skyGrad;
          ctx.fillRect(0, 0, VIRT_W, VIRT_H);

          // Distant mountains
          ctx.save();
          ctx.translate(-camX * 0.25, 0);
          drawMount(80, 260, 120);
          drawMount(280, 280, 90);
          drawMount(520, 260, 120);
          drawMount(800, 300, 110);
          drawMount(1100, 280, 95);
          ctx.restore();

          // Tiles visible region
          const xStart = Math.floor(camX / TILE),
            xEnd = Math.ceil((camX + VIRT_W) / TILE);
          for (let ty = 0; ty < grid.length; ty++) {
            for (let tx = xStart; tx <= xEnd && tx < grid[0].length; tx++) {
              const ch = getTile(tx, ty);
              const px = tx * TILE - camX,
                py = ty * TILE;
              if (ch === "#") drawBlock(px, py);
              else if (ch === "-") drawPlatform(px, py);
              else if (ch === "^") drawSpike(px, py);
              else if (ch === "L") drawLava(px, py);
            }
          }

          // Coins
          for (const c of coinsList) {
            if (c.got) continue;
            const x = c.x - camX,
              y = c.y + Math.sin(c.t) * 2;
            drawCoin(x, y);
          }

          // Enemies
          for (const e of enemies) {
            if (!e.alive) continue;
            drawEnemy(e.x - camX, e.y);
          }

          // Flag
          if (flagRect) {
            drawFlag(flagRect.x - camX, flagRect.y);
          }

          // Player
          drawPlayer(player.x - camX, player.y);

          if (state === "pause") drawPause();
        }

        function drawMount(x, base, h) {
          ctx.fillStyle = "#0e1a34";
          ctx.beginPath();
          ctx.moveTo(x - h, base);
          ctx.lineTo(x, base - h);
          ctx.lineTo(x + h, base);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = "#0c1730";
          ctx.beginPath();
          ctx.moveTo(x - h * 0.6, base);
          ctx.lineTo(x, base - h * 0.6);
          ctx.lineTo(x + h * 0.6, base);
          ctx.closePath();
          ctx.fill();
        }

        function drawBlock(x, y) {
          ctx.fillStyle = "#3b2f2f";
          ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = "#6d4c41";
          ctx.fillRect(x + 2, y + 2, TILE - 4, TILE - 6);
          ctx.fillStyle = "rgba(255,255,255,.07)";
          ctx.fillRect(x + 2, y + 2, TILE - 4, 4);
        }
        function drawPlatform(x, y) {
          ctx.fillStyle = "#4b5563";
          ctx.fillRect(x, y + 8, TILE, TILE - 8);
          ctx.fillStyle = "#9ca3af";
          ctx.fillRect(x, y + 8, TILE, 4);
        }
        function drawSpike(x, y) {
          ctx.fillStyle = "#c2410c";
          ctx.beginPath();
          const n = 3,
            w = TILE / n;
          for (let i = 0; i < n; i++) {
            ctx.moveTo(x + i * w, y + TILE);
            ctx.lineTo(x + i * w + w / 2, y + 8);
            ctx.lineTo(x + (i + 1) * w, y + TILE);
          }
          ctx.fill();
        }
        function drawLava(x, y) {
          ctx.fillStyle = "#7f1d1d";
          ctx.fillRect(x, y, TILE, TILE);
          ctx.fillStyle = "#ef4444";
          const t = (performance.now() / 300) % 1;
          const wave = 6 + Math.sin(x / 20 + t * 6) * 2;
          ctx.fillRect(x, y + TILE - 10, TILE, 10);
          ctx.beginPath();
          ctx.moveTo(x, y + TILE - 10);
          for (let i = 0; i <= TILE; i += 8) {
            const yy = y + TILE - 10 - Math.sin(i / 8 + t * 6) * 2;
            ctx.lineTo(x + i, yy);
          }
          ctx.lineTo(x + TILE, y + TILE - 10);
          ctx.closePath();
          ctx.fill();
        }
        function drawCoin(x, y) {
          ctx.save();
          ctx.translate(x + 8, y + 8);
          ctx.scale(1, 1.2);
          ctx.fillStyle = "#facc15";
          ctx.beginPath();
          ctx.arc(0, 0, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#fde68a";
          ctx.fillRect(-2, -6, 4, 12);
          ctx.restore();
        }
        function drawEnemy(x, y) {
          ctx.fillStyle = "#16a34a";
          ctx.fillRect(x, y + 10, 24, 16); // body
          ctx.fillStyle = "#14532d";
          ctx.fillRect(x + 2, y + 22, 8, 6);
          ctx.fillRect(x + 14, y + 22, 8, 6); // feet
          ctx.fillStyle = "#fff";
          ctx.fillRect(x + 4, y + 12, 6, 6);
          ctx.fillRect(x + 14, y + 12, 6, 6);
          ctx.fillStyle = "#111";
          ctx.fillRect(x + 6, y + 14, 2, 2);
          ctx.fillRect(x + 16, y + 14, 2, 2);
        }
        function drawFlag(x, y) {
          // pole
          ctx.fillStyle = "#cbd5e1";
          ctx.fillRect(x + 6, y, 4, 3 * TILE);
          // flag
          const t = Math.sin(performance.now() / 300) * 2;
          ctx.fillStyle = "#34d399";
          ctx.beginPath();
          ctx.moveTo(x + 10, y + 6);
          ctx.lineTo(x + 10 + 22, y + 10 + t);
          ctx.lineTo(x + 10, y + 18);
          ctx.closePath();
          ctx.fill();
        }
        function drawPlayer(x, y) {
          // invul blink
          if (player.invul > 0 && ((performance.now() / 80) | 0) % 2 === 0)
            return;
          // body
          ctx.fillStyle = "#60a5fa";
          ctx.fillRect(x, y + 6, 22, 22);
          // head
          ctx.fillStyle = "#93c5fd";
          ctx.fillRect(x + 2, y, 18, 12);
          // face
          ctx.fillStyle = "#111827";
          ctx.fillRect(x + 6, y + 4, 2, 2);
          ctx.fillRect(x + 14, y + 4, 2, 2);
          // hands/feet
          ctx.fillStyle = "#1d4ed8";
          ctx.fillRect(x - 2, y + 18, 6, 6);
          ctx.fillRect(x + 18, y + 18, 6, 6); // hands
          ctx.fillRect(x + 2, y + 26, 6, 6);
          ctx.fillRect(x + 14, y + 26, 6, 6); // feet
        }
        function drawPause() {
          ctx.fillStyle = "rgba(0,0,0,.45)";
          ctx.fillRect(0, 0, VIRT_W, VIRT_H);
          ctx.fillStyle = "#fff";
          ctx.font = "bold 24px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("일시정지 — P 키로 계속", VIRT_W / 2, VIRT_H / 2);
          ctx.textAlign = "left";
        }

        // Initial modal stays; pressing Enter can start too
        window.addEventListener("keydown", (e) => {
          if (state === "menu" && (e.code === "Enter" || e.code === "Space")) {
            closeModal();
            startGame();
          }
          if (state === "gameover" && e.code === "KeyR") {
            startGame();
          }
        });
      })();
    </script>
  </body>
</html>
